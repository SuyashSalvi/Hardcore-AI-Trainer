"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http_ece";
exports.ids = ["vendor-chunks/http_ece"];
exports.modules = {

/***/ "(rsc)/./node_modules/http_ece/ece.js":
/*!**************************************!*\
  !*** ./node_modules/http_ece/ece.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */ var crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar AES_GCM = \"aes-128-gcm\";\nvar PAD_SIZE = {\n    \"aes128gcm\": 1,\n    \"aesgcm\": 2\n};\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = \"encrypt\";\nvar MODE_DECRYPT = \"decrypt\";\nvar keylog;\nif (process.env.ECE_KEYLOG === \"1\") {\n    keylog = function(m, k) {\n        console.warn(m + \" [\" + k.length + \"]: \" + k.toString(\"base64url\"));\n        return k;\n    };\n} else {\n    keylog = function(m, k) {\n        return k;\n    };\n}\n/* Optionally base64 decode something. */ function decode(b) {\n    if (typeof b === \"string\") {\n        return Buffer.from(b, \"base64url\");\n    }\n    return b;\n}\nfunction HMAC_hash(key, input) {\n    var hmac = crypto.createHmac(\"sha256\", key);\n    hmac.update(input);\n    return hmac.digest();\n}\n/* HKDF as defined in RFC5869, using SHA-256 */ function HKDF_extract(salt, ikm) {\n    keylog(\"salt\", salt);\n    keylog(\"ikm\", ikm);\n    return keylog(\"extract\", HMAC_hash(salt, ikm));\n}\nfunction HKDF_expand(prk, info, l) {\n    keylog(\"prk\", prk);\n    keylog(\"info\", info);\n    var output = Buffer.alloc(0);\n    var T = Buffer.alloc(0);\n    info = Buffer.from(info, \"ascii\");\n    var counter = 0;\n    var cbuf = Buffer.alloc(1);\n    while(output.length < l){\n        cbuf.writeUIntBE(++counter, 0, 1);\n        T = HMAC_hash(prk, Buffer.concat([\n            T,\n            info,\n            cbuf\n        ]));\n        output = Buffer.concat([\n            output,\n            T\n        ]);\n    }\n    return keylog(\"expand\", output.slice(0, l));\n}\nfunction HKDF(salt, ikm, info, len) {\n    return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\nfunction info(base, context) {\n    var result = Buffer.concat([\n        Buffer.from(\"Content-Encoding: \" + base + \"\\x00\", \"ascii\"),\n        context\n    ]);\n    keylog(\"info \" + base, result);\n    return result;\n}\nfunction lengthPrefix(buffer) {\n    var b = Buffer.concat([\n        Buffer.alloc(2),\n        buffer\n    ]);\n    b.writeUIntBE(buffer.length, 0, 2);\n    return b;\n}\nfunction extractDH(header, mode) {\n    var key = header.privateKey;\n    var senderPubKey, receiverPubKey;\n    if (mode === MODE_ENCRYPT) {\n        senderPubKey = key.getPublicKey();\n        receiverPubKey = header.dh;\n    } else if (mode === MODE_DECRYPT) {\n        senderPubKey = header.dh;\n        receiverPubKey = key.getPublicKey();\n    } else {\n        throw new Error(\"Unknown mode only \" + MODE_ENCRYPT + \" and \" + MODE_DECRYPT + \" supported\");\n    }\n    return {\n        secret: key.computeSecret(header.dh),\n        context: Buffer.concat([\n            Buffer.from(header.keylabel, \"ascii\"),\n            Buffer.from([\n                0\n            ]),\n            lengthPrefix(receiverPubKey),\n            lengthPrefix(senderPubKey) // application server\n        ])\n    };\n}\nfunction extractSecretAndContext(header, mode) {\n    var result = {\n        secret: null,\n        context: Buffer.alloc(0)\n    };\n    if (header.key) {\n        result.secret = header.key;\n        if (result.secret.length !== KEY_LENGTH) {\n            throw new Error(\"An explicit key must be \" + KEY_LENGTH + \" bytes\");\n        }\n    } else if (header.dh) {\n        result = extractDH(header, mode);\n    } else if (typeof header.keyid !== undefined) {\n        result.secret = header.keymap[header.keyid];\n    }\n    if (!result.secret) {\n        throw new Error(\"Unable to determine key\");\n    }\n    keylog(\"secret\", result.secret);\n    keylog(\"context\", result.context);\n    if (header.authSecret) {\n        result.secret = HKDF(header.authSecret, result.secret, info(\"auth\", Buffer.alloc(0)), SHA_256_LENGTH);\n        keylog(\"authsecret\", result.secret);\n    }\n    return result;\n}\nfunction webpushSecret(header, mode) {\n    if (!header.authSecret) {\n        throw new Error(\"No authentication secret for webpush\");\n    }\n    keylog(\"authsecret\", header.authSecret);\n    var remotePubKey, senderPubKey, receiverPubKey;\n    if (mode === MODE_ENCRYPT) {\n        senderPubKey = header.privateKey.getPublicKey();\n        remotePubKey = receiverPubKey = header.dh;\n    } else if (mode === MODE_DECRYPT) {\n        remotePubKey = senderPubKey = header.keyid;\n        receiverPubKey = header.privateKey.getPublicKey();\n    } else {\n        throw new Error(\"Unknown mode only \" + MODE_ENCRYPT + \" and \" + MODE_DECRYPT + \" supported\");\n    }\n    keylog(\"remote pubkey\", remotePubKey);\n    keylog(\"sender pubkey\", senderPubKey);\n    keylog(\"receiver pubkey\", receiverPubKey);\n    return keylog(\"secret dh\", HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer.concat([\n        Buffer.from(\"WebPush: info\\x00\"),\n        receiverPubKey,\n        senderPubKey\n    ]), SHA_256_LENGTH));\n}\nfunction extractSecret(header, mode, keyLookupCallback) {\n    if (keyLookupCallback) {\n        if (!isFunction(keyLookupCallback)) {\n            throw new Error(\"Callback is not a function\");\n        }\n    }\n    if (header.key) {\n        if (header.key.length !== KEY_LENGTH) {\n            throw new Error(\"An explicit key must be \" + KEY_LENGTH + \" bytes\");\n        }\n        return keylog(\"secret key\", header.key);\n    }\n    if (!header.privateKey) {\n        // Lookup based on keyid\n        if (!keyLookupCallback) {\n            var key = header.keymap && header.keymap[header.keyid];\n        } else {\n            var key = keyLookupCallback(header.keyid);\n        }\n        if (!key) {\n            throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n        }\n        return key;\n    }\n    return webpushSecret(header, mode);\n}\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n    if (!header.salt) {\n        throw new Error(\"must include a salt parameter for \" + header.version);\n    }\n    var keyInfo;\n    var nonceInfo;\n    var secret;\n    if (header.version === \"aesgcm\") {\n        // old\n        var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n        keyInfo = info(\"aesgcm\", s.context);\n        nonceInfo = info(\"nonce\", s.context);\n        secret = s.secret;\n    } else if (header.version === \"aes128gcm\") {\n        // latest\n        keyInfo = Buffer.from(\"Content-Encoding: aes128gcm\\x00\");\n        nonceInfo = Buffer.from(\"Content-Encoding: nonce\\x00\");\n        secret = extractSecret(header, mode, lookupKeyCallback);\n    } else {\n        throw new Error(\"Unable to set context for mode \" + header.version);\n    }\n    var prk = HKDF_extract(header.salt, secret);\n    var result = {\n        key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n        nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n    };\n    keylog(\"key\", result.key);\n    keylog(\"nonce base\", result.nonce);\n    return result;\n}\n/* Parse command-line arguments. */ function parseParams(params) {\n    var header = {};\n    header.version = params.version || \"aes128gcm\";\n    header.rs = parseInt(params.rs, 10);\n    if (isNaN(header.rs)) {\n        header.rs = 4096;\n    }\n    var overhead = PAD_SIZE[header.version];\n    if (header.version === \"aes128gcm\") {\n        overhead += TAG_LENGTH;\n    }\n    if (header.rs <= overhead) {\n        throw new Error(\"The rs parameter has to be greater than \" + overhead);\n    }\n    if (params.salt) {\n        header.salt = decode(params.salt);\n        if (header.salt.length !== KEY_LENGTH) {\n            throw new Error(\"The salt parameter must be \" + KEY_LENGTH + \" bytes\");\n        }\n    }\n    header.keyid = params.keyid;\n    if (params.key) {\n        header.key = decode(params.key);\n    } else {\n        header.privateKey = params.privateKey;\n        if (!header.privateKey) {\n            header.keymap = params.keymap;\n        }\n        if (header.version !== \"aes128gcm\") {\n            header.keylabel = params.keylabel || \"P-256\";\n        }\n        if (params.dh) {\n            header.dh = decode(params.dh);\n        }\n    }\n    if (params.authSecret) {\n        header.authSecret = decode(params.authSecret);\n    }\n    return header;\n}\nfunction generateNonce(base, counter) {\n    var nonce = Buffer.from(base);\n    var m = nonce.readUIntBE(nonce.length - 6, 6);\n    var x = ((m ^ counter) & 0xffffff) + ((m / 0x1000000 ^ counter / 0x1000000) & 0xffffff) * 0x1000000;\n    nonce.writeUIntBE(x, nonce.length - 6, 6);\n    keylog(\"nonce\" + counter, nonce);\n    return nonce;\n}\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */ function readHeader(buffer, header) {\n    var idsz = buffer.readUIntBE(20, 1);\n    header.salt = buffer.slice(0, KEY_LENGTH);\n    header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n    header.keyid = buffer.slice(21, 21 + idsz);\n    return 21 + idsz;\n}\nfunction unpadLegacy(data, version) {\n    var padSize = PAD_SIZE[version];\n    var pad = data.readUIntBE(0, padSize);\n    if (pad + padSize > data.length) {\n        throw new Error(\"padding exceeds block size\");\n    }\n    keylog(\"padding\", data.slice(0, padSize + pad));\n    var padCheck = Buffer.alloc(pad);\n    padCheck.fill(0);\n    if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n        throw new Error(\"invalid padding\");\n    }\n    return data.slice(padSize + pad);\n}\nfunction unpad(data, last) {\n    var i = data.length - 1;\n    while(i >= 0){\n        if (data[i]) {\n            if (last) {\n                if (data[i] !== 2) {\n                    throw new Error(\"last record needs to start padding with a 2\");\n                }\n            } else {\n                if (data[i] !== 1) {\n                    throw new Error(\"last record needs to start padding with a 2\");\n                }\n            }\n            return data.slice(0, i);\n        }\n        --i;\n    }\n    throw new Error(\"all zero plaintext\");\n}\nfunction decryptRecord(key, counter, buffer, header, last) {\n    keylog(\"decrypt\", buffer);\n    var nonce = generateNonce(key.nonce, counter);\n    var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n    gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n    var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n    data = Buffer.concat([\n        data,\n        gcm.final()\n    ]);\n    keylog(\"decrypted\", data);\n    if (header.version !== \"aes128gcm\") {\n        return unpadLegacy(data, header.version);\n    }\n    return unpad(data, last);\n}\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */ function decrypt(buffer, params, keyLookupCallback) {\n    var header = parseParams(params);\n    if (header.version === \"aes128gcm\") {\n        var headerLength = readHeader(buffer, header);\n        buffer = buffer.slice(headerLength);\n    }\n    var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n    var start = 0;\n    var result = Buffer.alloc(0);\n    var chunkSize = header.rs;\n    if (header.version !== \"aes128gcm\") {\n        chunkSize += TAG_LENGTH;\n    }\n    for(var i = 0; start < buffer.length; ++i){\n        var end = start + chunkSize;\n        if (header.version !== \"aes128gcm\" && end === buffer.length) {\n            throw new Error(\"Truncated payload\");\n        }\n        end = Math.min(end, buffer.length);\n        if (end - start <= TAG_LENGTH) {\n            throw new Error(\"Invalid block: too small at \" + i);\n        }\n        var block = decryptRecord(key, i, buffer.slice(start, end), header, end >= buffer.length);\n        result = Buffer.concat([\n            result,\n            block\n        ]);\n        start = end;\n    }\n    return result;\n}\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n    keylog(\"encrypt\", buffer);\n    pad = pad || 0;\n    var nonce = generateNonce(key.nonce, counter);\n    var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n    var ciphertext = [];\n    var padSize = PAD_SIZE[header.version];\n    var padding = Buffer.alloc(pad + padSize);\n    padding.fill(0);\n    if (header.version !== \"aes128gcm\") {\n        padding.writeUIntBE(pad, 0, padSize);\n        keylog(\"padding\", padding);\n        ciphertext.push(gcm.update(padding));\n        ciphertext.push(gcm.update(buffer));\n        if (!last && padding.length + buffer.length < header.rs) {\n            throw new Error(\"Unable to pad to record size\");\n        }\n    } else {\n        ciphertext.push(gcm.update(buffer));\n        padding.writeUIntBE(last ? 2 : 1, 0, 1);\n        keylog(\"padding\", padding);\n        ciphertext.push(gcm.update(padding));\n    }\n    gcm.final();\n    var tag = gcm.getAuthTag();\n    if (tag.length !== TAG_LENGTH) {\n        throw new Error(\"invalid tag generated\");\n    }\n    ciphertext.push(tag);\n    return keylog(\"encrypted\", Buffer.concat(ciphertext));\n}\nfunction writeHeader(header) {\n    var ints = Buffer.alloc(5);\n    var keyid = Buffer.from(header.keyid || []);\n    if (keyid.length > 255) {\n        throw new Error(\"keyid is too large\");\n    }\n    ints.writeUIntBE(header.rs, 0, 4);\n    ints.writeUIntBE(keyid.length, 4, 1);\n    return Buffer.concat([\n        header.salt,\n        ints,\n        keyid\n    ]);\n}\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */ function encrypt(buffer, params, keyLookupCallback) {\n    if (!Buffer.isBuffer(buffer)) {\n        throw new Error(\"buffer argument must be a Buffer\");\n    }\n    var header = parseParams(params);\n    if (!header.salt) {\n        header.salt = crypto.randomBytes(KEY_LENGTH);\n    }\n    var result;\n    if (header.version === \"aes128gcm\") {\n        // Save the DH public key in the header unless keyid is set.\n        if (header.privateKey && !header.keyid) {\n            header.keyid = header.privateKey.getPublicKey();\n        }\n        result = writeHeader(header);\n    } else {\n        // No header on other versions\n        result = Buffer.alloc(0);\n    }\n    var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n    var start = 0;\n    var padSize = PAD_SIZE[header.version];\n    var overhead = padSize;\n    if (header.version === \"aes128gcm\") {\n        overhead += TAG_LENGTH;\n    }\n    var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n    var counter = 0;\n    var last = false;\n    while(!last){\n        // Pad so that at least one data byte is in a block.\n        var recordPad = Math.min(header.rs - overhead - 1, pad);\n        if (header.version !== \"aes128gcm\") {\n            recordPad = Math.min((1 << padSize * 8) - 1, recordPad);\n        }\n        if (pad > 0 && recordPad === 0) {\n            ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n        }\n        pad -= recordPad;\n        var end = start + header.rs - overhead - recordPad;\n        if (header.version !== \"aes128gcm\") {\n            // The > here ensures that we write out a padding-only block at the end\n            // of a buffer.\n            last = end > buffer.length;\n        } else {\n            last = end >= buffer.length;\n        }\n        last = last && pad <= 0;\n        var block = encryptRecord(key, counter, buffer.slice(start, end), recordPad, header, last);\n        result = Buffer.concat([\n            result,\n            block\n        ]);\n        start = end;\n        ++counter;\n    }\n    return result;\n}\nfunction isFunction(object) {\n    return typeof object === \"function\";\n}\nmodule.exports = {\n    decrypt: decrypt,\n    encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cF9lY2UvZWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBRXJCLElBQUlDLFVBQVU7QUFDZCxJQUFJQyxXQUFXO0lBQUUsYUFBYTtJQUFHLFVBQVU7QUFBRTtBQUM3QyxJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxlQUFlO0FBRW5CLElBQUlDO0FBQ0osSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxVQUFVLEtBQUssS0FBSztJQUNsQ0gsU0FBUyxTQUFTSSxDQUFDLEVBQUVDLENBQUM7UUFDcEJDLFFBQVFDLElBQUksQ0FBQ0gsSUFBSSxPQUFPQyxFQUFFRyxNQUFNLEdBQUcsUUFBUUgsRUFBRUksUUFBUSxDQUFDO1FBQ3RELE9BQU9KO0lBQ1Q7QUFDRixPQUFPO0lBQ0xMLFNBQVMsU0FBU0ksQ0FBQyxFQUFFQyxDQUFDO1FBQUksT0FBT0E7SUFBRztBQUN0QztBQUVBLHVDQUF1QyxHQUN2QyxTQUFTSyxPQUFPQyxDQUFDO0lBQ2YsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsSUFBSSxDQUFDRixHQUFHO0lBQ3hCO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLFNBQVNHLFVBQVVDLEdBQUcsRUFBRUMsS0FBSztJQUMzQixJQUFJQyxPQUFPM0IsT0FBTzRCLFVBQVUsQ0FBQyxVQUFVSDtJQUN2Q0UsS0FBS0UsTUFBTSxDQUFDSDtJQUNaLE9BQU9DLEtBQUtHLE1BQU07QUFDcEI7QUFFQSw2Q0FBNkMsR0FDN0MsU0FBU0MsYUFBYUMsSUFBSSxFQUFFQyxHQUFHO0lBQzdCdkIsT0FBTyxRQUFRc0I7SUFDZnRCLE9BQU8sT0FBT3VCO0lBQ2QsT0FBT3ZCLE9BQU8sV0FBV2MsVUFBVVEsTUFBTUM7QUFD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LFFBQVFFO1FBQ1IsRUFBRXZFO0lBQ0o7SUFDQSxPQUFPUztBQUNUO0FBR0EsU0FBU3dCLFdBQVd1RCxNQUFNO0lBQ3hCLE9BQU8sT0FBT0EsV0FBWTtBQUMzQjtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnZCLFNBQVNBO0lBQ1RpQixTQUFTQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29nZ2lucy1haS1jb2FjaC8uL25vZGVfbW9kdWxlcy9odHRwX2VjZS9lY2UuanM/NmQ3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKlxuICogRW5jcnlwdGVkIGNvbnRlbnQgY29kaW5nXG4gKlxuICogPT09IE5vdGUgYWJvdXQgdmVyc2lvbnMgPT09XG4gKlxuICogVGhpcyBjb2RlIHN1cHBvcnRzIG11bHRpcGxlIHZlcnNpb25zIG9mIHRoZSBkcmFmdC4gIFRoaXMgaXMgc2VsZWN0ZWQgdXNpbmdcbiAqIHRoZSB8dmVyc2lvbnwgcGFyYW1ldGVyLlxuICpcbiAqIGFlczEyOGdjbTogVGhlIG1vc3QgcmVjZW50IHZlcnNpb24sIHRoZSBzYWx0LCByZWNvcmQgc2l6ZSBhbmQga2V5IGlkZW50aWZpZXJcbiAqICAgIGFyZSBpbmNsdWRlZCBpbiBhIGhlYWRlciB0aGF0IGlzIHBhcnQgb2YgdGhlIGVuY3J5cHRlZCBjb250ZW50IGNvZGluZy5cbiAqXG4gKiBhZXNnY206IFRoZSB2ZXJzaW9uIHRoYXQgaXMgd2lkZWx5IGRlcGxveWVkIHdpdGggV2ViUHVzaCAoYXMgb2YgMjAxNi0xMSkuXG4gKiAgICBUaGlzIHZlcnNpb24gaXMgc2VsZWN0ZWQgYnkgZGVmYXVsdCwgdW5sZXNzIHlvdSBzcGVjaWZ5IGEgfHBhZFNpemV8IG9mIDEuXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgQUVTX0dDTSA9ICdhZXMtMTI4LWdjbSc7XG52YXIgUEFEX1NJWkUgPSB7ICdhZXMxMjhnY20nOiAxLCAnYWVzZ2NtJzogMiB9O1xudmFyIFRBR19MRU5HVEggPSAxNjtcbnZhciBLRVlfTEVOR1RIID0gMTY7XG52YXIgTk9OQ0VfTEVOR1RIID0gMTI7XG52YXIgU0hBXzI1Nl9MRU5HVEggPSAzMjtcbnZhciBNT0RFX0VOQ1JZUFQgPSAnZW5jcnlwdCc7XG52YXIgTU9ERV9ERUNSWVBUID0gJ2RlY3J5cHQnO1xuXG52YXIga2V5bG9nO1xuaWYgKHByb2Nlc3MuZW52LkVDRV9LRVlMT0cgPT09ICcxJykge1xuICBrZXlsb2cgPSBmdW5jdGlvbihtLCBrKSB7XG4gICAgY29uc29sZS53YXJuKG0gKyAnIFsnICsgay5sZW5ndGggKyAnXTogJyArIGsudG9TdHJpbmcoJ2Jhc2U2NHVybCcpKTtcbiAgICByZXR1cm4gaztcbiAgfTtcbn0gZWxzZSB7XG4gIGtleWxvZyA9IGZ1bmN0aW9uKG0sIGspIHsgcmV0dXJuIGs7IH07XG59XG5cbi8qIE9wdGlvbmFsbHkgYmFzZTY0IGRlY29kZSBzb21ldGhpbmcuICovXG5mdW5jdGlvbiBkZWNvZGUoYikge1xuICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGIsICdiYXNlNjR1cmwnKTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gSE1BQ19oYXNoKGtleSwgaW5wdXQpIHtcbiAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KTtcbiAgaG1hYy51cGRhdGUoaW5wdXQpO1xuICByZXR1cm4gaG1hYy5kaWdlc3QoKTtcbn1cblxuLyogSEtERiBhcyBkZWZpbmVkIGluIFJGQzU4NjksIHVzaW5nIFNIQS0yNTYgKi9cbmZ1bmN0aW9uIEhLREZfZXh0cmFjdChzYWx0LCBpa20pIHtcbiAga2V5bG9nKCdzYWx0Jywgc2FsdCk7XG4gIGtleWxvZygnaWttJywgaWttKTtcbiAgcmV0dXJuIGtleWxvZygnZXh0cmFjdCcsIEhNQUNfaGFzaChzYWx0LCBpa20pKTtcbn1cblxuZnVuY3Rpb24gSEtERl9leHBhbmQocHJrLCBpbmZvLCBsKSB7XG4gIGtleWxvZygncHJrJywgcHJrKTtcbiAga2V5bG9nKCdpbmZvJywgaW5mbyk7XG4gIHZhciBvdXRwdXQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHZhciBUID0gQnVmZmVyLmFsbG9jKDApO1xuICBpbmZvID0gQnVmZmVyLmZyb20oaW5mbywgJ2FzY2lpJyk7XG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGNidWYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgbCkge1xuICAgIGNidWYud3JpdGVVSW50QkUoKytjb3VudGVyLCAwLCAxKTtcbiAgICBUID0gSE1BQ19oYXNoKHByaywgQnVmZmVyLmNvbmNhdChbVCwgaW5mbywgY2J1Zl0pKTtcbiAgICBvdXRwdXQgPSBCdWZmZXIuY29uY2F0KFtvdXRwdXQsIFRdKTtcbiAgfVxuXG4gIHJldHVybiBrZXlsb2coJ2V4cGFuZCcsIG91dHB1dC5zbGljZSgwLCBsKSk7XG59XG5cbmZ1bmN0aW9uIEhLREYoc2FsdCwgaWttLCBpbmZvLCBsZW4pIHtcbiAgcmV0dXJuIEhLREZfZXhwYW5kKEhLREZfZXh0cmFjdChzYWx0LCBpa20pLCBpbmZvLCBsZW4pO1xufVxuXG5mdW5jdGlvbiBpbmZvKGJhc2UsIGNvbnRleHQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIEJ1ZmZlci5mcm9tKCdDb250ZW50LUVuY29kaW5nOiAnICsgYmFzZSArICdcXDAnLCAnYXNjaWknKSxcbiAgICBjb250ZXh0XG4gIF0pO1xuICBrZXlsb2coJ2luZm8gJyArIGJhc2UsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFByZWZpeChidWZmZXIpIHtcbiAgdmFyIGIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMiksIGJ1ZmZlcl0pO1xuICBiLndyaXRlVUludEJFKGJ1ZmZlci5sZW5ndGgsIDAsIDIpO1xuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERIKGhlYWRlciwgbW9kZSkge1xuICB2YXIga2V5ID0gaGVhZGVyLnByaXZhdGVLZXk7XG4gIHZhciBzZW5kZXJQdWJLZXksIHJlY2VpdmVyUHViS2V5O1xuICBpZiAobW9kZSA9PT0gTU9ERV9FTkNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0ga2V5LmdldFB1YmxpY0tleSgpO1xuICAgIHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IE1PREVfREVDUllQVCkge1xuICAgIHNlbmRlclB1YktleSA9IGhlYWRlci5kaDtcbiAgICByZWNlaXZlclB1YktleSA9IGtleS5nZXRQdWJsaWNLZXkoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSBvbmx5ICcgKyBNT0RFX0VOQ1JZUFQgK1xuICAgICAgICAgICAgICAgICAgICAnIGFuZCAnICsgTU9ERV9ERUNSWVBUICsgJyBzdXBwb3J0ZWQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNlY3JldDoga2V5LmNvbXB1dGVTZWNyZXQoaGVhZGVyLmRoKSxcbiAgICBjb250ZXh0OiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKGhlYWRlci5rZXlsYWJlbCwgJ2FzY2lpJyksXG4gICAgICBCdWZmZXIuZnJvbShbMF0pLFxuICAgICAgbGVuZ3RoUHJlZml4KHJlY2VpdmVyUHViS2V5KSwgLy8gdXNlciBhZ2VudFxuICAgICAgbGVuZ3RoUHJlZml4KHNlbmRlclB1YktleSkgICAgLy8gYXBwbGljYXRpb24gc2VydmVyXG4gICAgXSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFNlY3JldEFuZENvbnRleHQoaGVhZGVyLCBtb2RlKSB7XG4gIHZhciByZXN1bHQgPSB7IHNlY3JldDogbnVsbCwgY29udGV4dDogQnVmZmVyLmFsbG9jKDApIH07XG4gIGlmIChoZWFkZXIua2V5KSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IGhlYWRlci5rZXk7XG4gICAgaWYgKHJlc3VsdC5zZWNyZXQubGVuZ3RoICE9PSBLRVlfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGV4cGxpY2l0IGtleSBtdXN0IGJlICcgKyBLRVlfTEVOR1RIICsgJyBieXRlcycpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXIuZGgpIHsgLy8gcmVjZWl2ZXIvZGVjcnlwdFxuICAgIHJlc3VsdCA9IGV4dHJhY3RESChoZWFkZXIsIG1vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXIua2V5aWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlc3VsdC5zZWNyZXQgPSBoZWFkZXIua2V5bWFwW2hlYWRlci5rZXlpZF07XG4gIH1cbiAgaWYgKCFyZXN1bHQuc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIGtleScpO1xuICB9XG4gIGtleWxvZygnc2VjcmV0JywgcmVzdWx0LnNlY3JldCk7XG4gIGtleWxvZygnY29udGV4dCcsIHJlc3VsdC5jb250ZXh0KTtcbiAgaWYgKGhlYWRlci5hdXRoU2VjcmV0KSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IEhLREYoaGVhZGVyLmF1dGhTZWNyZXQsIHJlc3VsdC5zZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5mbygnYXV0aCcsIEJ1ZmZlci5hbGxvYygwKSksIFNIQV8yNTZfTEVOR1RIKTtcbiAgICBrZXlsb2coJ2F1dGhzZWNyZXQnLCByZXN1bHQuc2VjcmV0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3ZWJwdXNoU2VjcmV0KGhlYWRlciwgbW9kZSkge1xuICBpZiAoIWhlYWRlci5hdXRoU2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRoZW50aWNhdGlvbiBzZWNyZXQgZm9yIHdlYnB1c2gnKTtcbiAgfVxuICBrZXlsb2coJ2F1dGhzZWNyZXQnLCBoZWFkZXIuYXV0aFNlY3JldCk7XG5cbiAgdmFyIHJlbW90ZVB1YktleSwgc2VuZGVyUHViS2V5LCByZWNlaXZlclB1YktleTtcbiAgaWYgKG1vZGUgPT09IE1PREVfRU5DUllQVCkge1xuICAgIHNlbmRlclB1YktleSA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICAgIHJlbW90ZVB1YktleSA9IHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IE1PREVfREVDUllQVCkge1xuICAgIHJlbW90ZVB1YktleSA9IHNlbmRlclB1YktleSA9IGhlYWRlci5rZXlpZDtcbiAgICByZWNlaXZlclB1YktleSA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlIG9ubHkgJyArIE1PREVfRU5DUllQVCArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kICcgKyBNT0RFX0RFQ1JZUFQgKyAnIHN1cHBvcnRlZCcpO1xuICB9XG4gIGtleWxvZygncmVtb3RlIHB1YmtleScsIHJlbW90ZVB1YktleSk7XG4gIGtleWxvZygnc2VuZGVyIHB1YmtleScsIHNlbmRlclB1YktleSk7XG4gIGtleWxvZygncmVjZWl2ZXIgcHVia2V5JywgcmVjZWl2ZXJQdWJLZXkpO1xuICByZXR1cm4ga2V5bG9nKCdzZWNyZXQgZGgnLFxuICAgICAgICAgICAgICAgIEhLREYoaGVhZGVyLmF1dGhTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICBoZWFkZXIucHJpdmF0ZUtleS5jb21wdXRlU2VjcmV0KHJlbW90ZVB1YktleSksXG4gICAgICAgICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oJ1dlYlB1c2g6IGluZm9cXDAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJQdWJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclB1YktleVxuICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICBTSEFfMjU2X0xFTkdUSCkpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2VjcmV0KGhlYWRlciwgbW9kZSwga2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgaWYgKGtleUxvb2t1cENhbGxiYWNrKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGtleUxvb2t1cENhbGxiYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbicpXG4gICAgfVxuICB9XG5cbiAgaWYgKGhlYWRlci5rZXkpIHtcbiAgICBpZiAoaGVhZGVyLmtleS5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXhwbGljaXQga2V5IG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlsb2coJ3NlY3JldCBrZXknLCBoZWFkZXIua2V5KTtcbiAgfVxuXG4gIGlmICghaGVhZGVyLnByaXZhdGVLZXkpIHtcbiAgICAvLyBMb29rdXAgYmFzZWQgb24ga2V5aWRcbiAgICBpZiAoIWtleUxvb2t1cENhbGxiYWNrKSB7XG4gICAgICB2YXIga2V5ID0gaGVhZGVyLmtleW1hcCAmJiBoZWFkZXIua2V5bWFwW2hlYWRlci5rZXlpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBrZXlMb29rdXBDYWxsYmFjayhoZWFkZXIua2V5aWQpXG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNhdmVkIGtleSAoa2V5aWQ6IFwiJyArIGhlYWRlci5rZXlpZCArICdcIiknKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIHJldHVybiB3ZWJwdXNoU2VjcmV0KGhlYWRlciwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGRlcml2ZUtleUFuZE5vbmNlKGhlYWRlciwgbW9kZSwgbG9va3VwS2V5Q2FsbGJhY2spIHtcbiAgaWYgKCFoZWFkZXIuc2FsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBpbmNsdWRlIGEgc2FsdCBwYXJhbWV0ZXIgZm9yICcgKyBoZWFkZXIudmVyc2lvbik7XG4gIH1cbiAgdmFyIGtleUluZm87XG4gIHZhciBub25jZUluZm87XG4gIHZhciBzZWNyZXQ7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2Flc2djbScpIHtcbiAgICAvLyBvbGRcbiAgICB2YXIgcyA9IGV4dHJhY3RTZWNyZXRBbmRDb250ZXh0KGhlYWRlciwgbW9kZSwgbG9va3VwS2V5Q2FsbGJhY2spO1xuICAgIGtleUluZm8gPSBpbmZvKCdhZXNnY20nLCBzLmNvbnRleHQpO1xuICAgIG5vbmNlSW5mbyA9IGluZm8oJ25vbmNlJywgcy5jb250ZXh0KTtcbiAgICBzZWNyZXQgPSBzLnNlY3JldDtcbiAgfSBlbHNlIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICAvLyBsYXRlc3RcbiAgICBrZXlJbmZvID0gQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6IGFlczEyOGdjbVxcMCcpO1xuICAgIG5vbmNlSW5mbyA9IEJ1ZmZlci5mcm9tKCdDb250ZW50LUVuY29kaW5nOiBub25jZVxcMCcpO1xuICAgIHNlY3JldCA9IGV4dHJhY3RTZWNyZXQoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGNvbnRleHQgZm9yIG1vZGUgJyArIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICB2YXIgcHJrID0gSEtERl9leHRyYWN0KGhlYWRlci5zYWx0LCBzZWNyZXQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIGtleTogSEtERl9leHBhbmQocHJrLCBrZXlJbmZvLCBLRVlfTEVOR1RIKSxcbiAgICBub25jZTogSEtERl9leHBhbmQocHJrLCBub25jZUluZm8sIE5PTkNFX0xFTkdUSClcbiAgfTtcbiAga2V5bG9nKCdrZXknLCByZXN1bHQua2V5KTtcbiAga2V5bG9nKCdub25jZSBiYXNlJywgcmVzdWx0Lm5vbmNlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyogUGFyc2UgY29tbWFuZC1saW5lIGFyZ3VtZW50cy4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKHBhcmFtcykge1xuICB2YXIgaGVhZGVyID0ge307XG5cbiAgaGVhZGVyLnZlcnNpb24gPSBwYXJhbXMudmVyc2lvbiB8fCAnYWVzMTI4Z2NtJztcbiAgaGVhZGVyLnJzID0gcGFyc2VJbnQocGFyYW1zLnJzLCAxMCk7XG4gIGlmIChpc05hTihoZWFkZXIucnMpKSB7XG4gICAgaGVhZGVyLnJzID0gNDA5NjtcbiAgfVxuICB2YXIgb3ZlcmhlYWQgPSBQQURfU0laRVtoZWFkZXIudmVyc2lvbl07XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICBvdmVyaGVhZCArPSBUQUdfTEVOR1RIO1xuICB9XG4gIGlmIChoZWFkZXIucnMgPD0gb3ZlcmhlYWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBycyBwYXJhbWV0ZXIgaGFzIHRvIGJlIGdyZWF0ZXIgdGhhbiAnICsgb3ZlcmhlYWQpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5zYWx0KSB7XG4gICAgaGVhZGVyLnNhbHQgPSBkZWNvZGUocGFyYW1zLnNhbHQpO1xuICAgIGlmIChoZWFkZXIuc2FsdC5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNhbHQgcGFyYW1ldGVyIG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICB9XG4gIGhlYWRlci5rZXlpZCA9IHBhcmFtcy5rZXlpZDtcbiAgaWYgKHBhcmFtcy5rZXkpIHtcbiAgICBoZWFkZXIua2V5ID0gZGVjb2RlKHBhcmFtcy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGhlYWRlci5wcml2YXRlS2V5ID0gcGFyYW1zLnByaXZhdGVLZXk7XG4gICAgaWYgKCFoZWFkZXIucHJpdmF0ZUtleSkge1xuICAgICAgaGVhZGVyLmtleW1hcCA9IHBhcmFtcy5rZXltYXA7XG4gICAgfVxuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIGhlYWRlci5rZXlsYWJlbCA9IHBhcmFtcy5rZXlsYWJlbCB8fCAnUC0yNTYnO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmRoKSB7XG4gICAgICBoZWFkZXIuZGggPSBkZWNvZGUocGFyYW1zLmRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRoU2VjcmV0KSB7XG4gICAgaGVhZGVyLmF1dGhTZWNyZXQgPSBkZWNvZGUocGFyYW1zLmF1dGhTZWNyZXQpO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTm9uY2UoYmFzZSwgY291bnRlcikge1xuICB2YXIgbm9uY2UgPSBCdWZmZXIuZnJvbShiYXNlKTtcbiAgdmFyIG0gPSBub25jZS5yZWFkVUludEJFKG5vbmNlLmxlbmd0aCAtIDYsIDYpO1xuICB2YXIgeCA9ICgobSBeIGNvdW50ZXIpICYgMHhmZmZmZmYpICtcbiAgICAgICgoKChtIC8gMHgxMDAwMDAwKSBeIChjb3VudGVyIC8gMHgxMDAwMDAwKSkgJiAweGZmZmZmZikgKiAweDEwMDAwMDApO1xuICBub25jZS53cml0ZVVJbnRCRSh4LCBub25jZS5sZW5ndGggLSA2LCA2KTtcbiAga2V5bG9nKCdub25jZScgKyBjb3VudGVyLCBub25jZSk7XG4gIHJldHVybiBub25jZTtcbn1cblxuLyogVXNlZCB3aGVuIGRlY3J5cHRpbmcgYWVzMTI4Z2NtIHRvIHBvcHVsYXRlIHRoZSBoZWFkZXIgdmFsdWVzLiBNb2RpZmllcyB0aGVcbiAqIGhlYWRlciB2YWx1ZXMgaW4gcGxhY2UgYW5kIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIGhlYWRlci4gKi9cbmZ1bmN0aW9uIHJlYWRIZWFkZXIoYnVmZmVyLCBoZWFkZXIpIHtcbiAgdmFyIGlkc3ogPSBidWZmZXIucmVhZFVJbnRCRSgyMCwgMSk7XG4gIGhlYWRlci5zYWx0ID0gYnVmZmVyLnNsaWNlKDAsIEtFWV9MRU5HVEgpO1xuICBoZWFkZXIucnMgPSBidWZmZXIucmVhZFVJbnRCRShLRVlfTEVOR1RILCA0KTtcbiAgaGVhZGVyLmtleWlkID0gYnVmZmVyLnNsaWNlKDIxLCAyMSArIGlkc3opO1xuICByZXR1cm4gMjEgKyBpZHN6O1xufVxuXG5mdW5jdGlvbiB1bnBhZExlZ2FjeShkYXRhLCB2ZXJzaW9uKSB7XG4gIHZhciBwYWRTaXplID0gUEFEX1NJWkVbdmVyc2lvbl07XG4gIHZhciBwYWQgPSBkYXRhLnJlYWRVSW50QkUoMCwgcGFkU2l6ZSk7XG4gIGlmIChwYWQgKyBwYWRTaXplID4gZGF0YS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgZXhjZWVkcyBibG9jayBzaXplJyk7XG4gIH1cbiAga2V5bG9nKCdwYWRkaW5nJywgZGF0YS5zbGljZSgwLCBwYWRTaXplICsgcGFkKSk7XG4gIHZhciBwYWRDaGVjayA9IEJ1ZmZlci5hbGxvYyhwYWQpO1xuICBwYWRDaGVjay5maWxsKDApO1xuICBpZiAocGFkQ2hlY2suY29tcGFyZShkYXRhLnNsaWNlKHBhZFNpemUsIHBhZFNpemUgKyBwYWQpKSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYWRkaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGRhdGEuc2xpY2UocGFkU2l6ZSArIHBhZCk7XG59XG5cbmZ1bmN0aW9uIHVucGFkKGRhdGEsIGxhc3QpIHtcbiAgdmFyIGkgPSBkYXRhLmxlbmd0aCAtIDE7XG4gIHdoaWxlKGkgPj0gMCkge1xuICAgIGlmIChkYXRhW2ldKSB7XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdCByZWNvcmQgbmVlZHMgdG8gc3RhcnQgcGFkZGluZyB3aXRoIGEgMicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdCByZWNvcmQgbmVlZHMgdG8gc3RhcnQgcGFkZGluZyB3aXRoIGEgMicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgLS1pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignYWxsIHplcm8gcGxhaW50ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uIGRlY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIsIGhlYWRlciwgbGFzdCkge1xuICBrZXlsb2coJ2RlY3J5cHQnLCBidWZmZXIpO1xuICB2YXIgbm9uY2UgPSBnZW5lcmF0ZU5vbmNlKGtleS5ub25jZSwgY291bnRlcik7XG4gIHZhciBnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihBRVNfR0NNLCBrZXkua2V5LCBub25jZSk7XG4gIGdjbS5zZXRBdXRoVGFnKGJ1ZmZlci5zbGljZShidWZmZXIubGVuZ3RoIC0gVEFHX0xFTkdUSCkpO1xuICB2YXIgZGF0YSA9IGdjbS51cGRhdGUoYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBUQUdfTEVOR1RIKSk7XG4gIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkYXRhLCBnY20uZmluYWwoKV0pO1xuICBrZXlsb2coJ2RlY3J5cHRlZCcsIGRhdGEpO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgcmV0dXJuIHVucGFkTGVnYWN5KGRhdGEsIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gdW5wYWQoZGF0YSwgbGFzdCk7XG59XG5cbi8qKlxuICogRGVjcnlwdCBzb21lIGJ5dGVzLiAgVGhpcyB1c2VzIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSB0aGUga2V5IGFuZCBibG9ja1xuICogc2l6ZSwgd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiB0aGUgZHJhZnQuICBCaW5hcnkgdmFsdWVzIGFyZSBiYXNlNjR1cmwgZW5jb2RlZC5cbiAqXG4gKiB8cGFyYW1zLnZlcnNpb258IGNvbnRhaW5zIHRoZSB2ZXJzaW9uIG9mIGVuY29kaW5nIHRvIHVzZTogYWVzMTI4Z2NtIGlzIHRoZSBsYXRlc3QsXG4gKiBidXQgYWVzZ2NtIGlzIGFsc28gYWNjZXB0ZWQgKHRob3VnaCB0aGUgbGF0dGVyIG1pZ2h0XG4gKiBkaXNhcHBlYXIgaW4gYSBmdXR1cmUgcmVsZWFzZSkuICBJZiBvbWl0dGVkLCBhc3N1bWUgYWVzMTI4Z2NtLlxuICpcbiAqIElmIHxwYXJhbXMua2V5fCBpcyBzcGVjaWZpZWQsIHRoYXQgdmFsdWUgaXMgdXNlZCBhcyB0aGUga2V5LlxuICpcbiAqIElmIHRoZSB2ZXJzaW9uIGlzIGFlczEyOGdjbSwgdGhlIGtleWlkIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBoZWFkZXIgYW5kIHVzZWRcbiAqIGFzIHRoZSBFQ0RIIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlci4gIEZvciB2ZXJzaW9uIGFlc2djbSAsXG4gKiB8cGFyYW1zLmRofCBuZWVkcyB0byBiZSBwcm92aWRlZCB3aXRoIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIuXG4gKlxuICogVGhlIHxwYXJhbXMucHJpdmF0ZUtleXwgaW5jbHVkZXMgdGhlIHByaXZhdGUga2V5IG9mIHRoZSByZWNlaXZlci5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdChidWZmZXIsIHBhcmFtcywga2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlciA9IHBhcnNlUGFyYW1zKHBhcmFtcyk7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gcmVhZEhlYWRlcihidWZmZXIsIGhlYWRlcik7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGhlYWRlckxlbmd0aCk7XG4gIH1cbiAgdmFyIGtleSA9IGRlcml2ZUtleUFuZE5vbmNlKGhlYWRlciwgTU9ERV9ERUNSWVBULCBrZXlMb29rdXBDYWxsYmFjayk7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgdmFyIGNodW5rU2l6ZSA9IGhlYWRlci5ycztcbiAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgIGNodW5rU2l6ZSArPSBUQUdfTEVOR1RIO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHN0YXJ0IDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgY2h1bmtTaXplO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScgJiYgZW5kID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RydW5jYXRlZCBwYXlsb2FkJyk7XG4gICAgfVxuICAgIGVuZCA9IE1hdGgubWluKGVuZCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IFRBR19MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jazogdG9vIHNtYWxsIGF0ICcgKyBpKTtcbiAgICB9XG4gICAgdmFyIGJsb2NrID0gZGVjcnlwdFJlY29yZChrZXksIGksIGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciwgZW5kID49IGJ1ZmZlci5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgYmxvY2tdKTtcbiAgICBzdGFydCA9IGVuZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0UmVjb3JkKGtleSwgY291bnRlciwgYnVmZmVyLCBwYWQsIGhlYWRlciwgbGFzdCkge1xuICBrZXlsb2coJ2VuY3J5cHQnLCBidWZmZXIpO1xuICBwYWQgPSBwYWQgfHwgMDtcbiAgdmFyIG5vbmNlID0gZ2VuZXJhdGVOb25jZShrZXkubm9uY2UsIGNvdW50ZXIpO1xuICB2YXIgZ2NtID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19HQ00sIGtleS5rZXksIG5vbmNlKTtcblxuICB2YXIgY2lwaGVydGV4dCA9IFtdO1xuICB2YXIgcGFkU2l6ZSA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgdmFyIHBhZGRpbmcgPSBCdWZmZXIuYWxsb2MocGFkICsgcGFkU2l6ZSk7XG4gIHBhZGRpbmcuZmlsbCgwKTtcblxuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgcGFkZGluZy53cml0ZVVJbnRCRShwYWQsIDAsIHBhZFNpemUpO1xuICAgIGtleWxvZygncGFkZGluZycsIHBhZGRpbmcpO1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKHBhZGRpbmcpKTtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShidWZmZXIpKTtcblxuICAgIGlmICghbGFzdCAmJiBwYWRkaW5nLmxlbmd0aCArIGJ1ZmZlci5sZW5ndGggPCBoZWFkZXIucnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhZCB0byByZWNvcmQgc2l6ZScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShidWZmZXIpKTtcbiAgICBwYWRkaW5nLndyaXRlVUludEJFKGxhc3QgPyAyIDogMSwgMCwgMSk7XG4gICAga2V5bG9nKCdwYWRkaW5nJywgcGFkZGluZyk7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUocGFkZGluZykpO1xuICB9XG5cbiAgZ2NtLmZpbmFsKCk7XG4gIHZhciB0YWcgPSBnY20uZ2V0QXV0aFRhZygpO1xuICBpZiAodGFnLmxlbmd0aCAhPT0gVEFHX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YWcgZ2VuZXJhdGVkJyk7XG4gIH1cbiAgY2lwaGVydGV4dC5wdXNoKHRhZyk7XG4gIHJldHVybiBrZXlsb2coJ2VuY3J5cHRlZCcsIEJ1ZmZlci5jb25jYXQoY2lwaGVydGV4dCkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUhlYWRlcihoZWFkZXIpIHtcbiAgdmFyIGludHMgPSBCdWZmZXIuYWxsb2MoNSk7XG4gIHZhciBrZXlpZCA9IEJ1ZmZlci5mcm9tKGhlYWRlci5rZXlpZCB8fCBbXSk7XG4gIGlmIChrZXlpZC5sZW5ndGggPiAyNTUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWlkIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIGludHMud3JpdGVVSW50QkUoaGVhZGVyLnJzLCAwLCA0KTtcbiAgaW50cy53cml0ZVVJbnRCRShrZXlpZC5sZW5ndGgsIDQsIDEpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaGVhZGVyLnNhbHQsIGludHMsIGtleWlkXSk7XG59XG5cbi8qKlxuICogRW5jcnlwdCBzb21lIGJ5dGVzLiAgVGhpcyB1c2VzIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSB0aGUga2V5IGFuZCBibG9ja1xuICogc2l6ZSwgd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiB0aGUgZHJhZnQuXG4gKlxuICogfHBhcmFtcy52ZXJzaW9ufCBjb250YWlucyB0aGUgdmVyc2lvbiBvZiBlbmNvZGluZyB0byB1c2U6IGFlczEyOGdjbSBpcyB0aGUgbGF0ZXN0LFxuICogYnV0IGFlc2djbSBpcyBhbHNvIGFjY2VwdGVkICh0aG91Z2ggdGhlIGxhdHRlciB0d28gbWlnaHRcbiAqIGRpc2FwcGVhciBpbiBhIGZ1dHVyZSByZWxlYXNlKS4gIElmIG9taXR0ZWQsIGFzc3VtZSBhZXMxMjhnY20uXG4gKlxuICogSWYgfHBhcmFtcy5rZXl8IGlzIHNwZWNpZmllZCwgdGhhdCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gKlxuICogRm9yIERpZmZpZS1IZWxsbWFuIChXZWJQdXNoKSwgfHBhcmFtcy5kaHwgaW5jbHVkZXMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlXG4gKiByZWNlaXZlci4gIHxwYXJhbXMucHJpdmF0ZUtleXwgaXMgdXNlZCB0byBlc3RhYmxpc2ggYSBzaGFyZWQgc2VjcmV0LiAgS2V5XG4gKiBwYWlycyBjYW4gYmUgY3JlYXRlZCB1c2luZyB8Y3J5cHRvLmNyZWF0ZUVDREgoKXwuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoYnVmZmVyLCBwYXJhbXMsIGtleUxvb2t1cENhbGxiYWNrKSB7ICBcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtcbiAgfVxuICB2YXIgaGVhZGVyID0gcGFyc2VQYXJhbXMocGFyYW1zKTtcbiAgaWYgKCFoZWFkZXIuc2FsdCkge1xuICAgIGhlYWRlci5zYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKEtFWV9MRU5HVEgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIC8vIFNhdmUgdGhlIERIIHB1YmxpYyBrZXkgaW4gdGhlIGhlYWRlciB1bmxlc3Mga2V5aWQgaXMgc2V0LlxuICAgIGlmIChoZWFkZXIucHJpdmF0ZUtleSAmJiAhaGVhZGVyLmtleWlkKSB7XG4gICAgICBoZWFkZXIua2V5aWQgPSBoZWFkZXIucHJpdmF0ZUtleS5nZXRQdWJsaWNLZXkoKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gd3JpdGVIZWFkZXIoaGVhZGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBoZWFkZXIgb24gb3RoZXIgdmVyc2lvbnNcbiAgICByZXN1bHQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cblxuICB2YXIga2V5ID0gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBNT0RFX0VOQ1JZUFQsIGtleUxvb2t1cENhbGxiYWNrKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHBhZFNpemUgPSBQQURfU0laRVtoZWFkZXIudmVyc2lvbl07XG4gIHZhciBvdmVyaGVhZCA9IHBhZFNpemU7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICBvdmVyaGVhZCArPSBUQUdfTEVOR1RIO1xuICB9XG4gIHZhciBwYWQgPSBpc05hTihwYXJzZUludChwYXJhbXMucGFkLCAxMCkpID8gMCA6IHBhcnNlSW50KHBhcmFtcy5wYWQsIDEwKTtcblxuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsYXN0ID0gZmFsc2U7XG4gIHdoaWxlICghbGFzdCkge1xuICAgIC8vIFBhZCBzbyB0aGF0IGF0IGxlYXN0IG9uZSBkYXRhIGJ5dGUgaXMgaW4gYSBibG9jay5cbiAgICB2YXIgcmVjb3JkUGFkID0gTWF0aC5taW4oaGVhZGVyLnJzIC0gb3ZlcmhlYWQgLSAxLCBwYWQpO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIHJlY29yZFBhZCA9IE1hdGgubWluKCgxIDw8IChwYWRTaXplICogOCkpIC0gMSwgcmVjb3JkUGFkKTtcbiAgICB9XG4gICAgaWYgKHBhZCA+IDAgJiYgcmVjb3JkUGFkID09PSAwKSB7XG4gICAgICArK3JlY29yZFBhZDsgLy8gRGVhbCB3aXRoIHBlcnZlcnNlIGNhc2Ugb2YgcnM9b3ZlcmhlYWQrMSB3aXRoIHBhZGRpbmcuXG4gICAgfVxuICAgIHBhZCAtPSByZWNvcmRQYWQ7XG5cbiAgICB2YXIgZW5kID0gc3RhcnQgKyBoZWFkZXIucnMgLSBvdmVyaGVhZCAtIHJlY29yZFBhZDtcbiAgICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgICAvLyBUaGUgPiBoZXJlIGVuc3VyZXMgdGhhdCB3ZSB3cml0ZSBvdXQgYSBwYWRkaW5nLW9ubHkgYmxvY2sgYXQgdGhlIGVuZFxuICAgICAgLy8gb2YgYSBidWZmZXIuXG4gICAgICBsYXN0ID0gZW5kID4gYnVmZmVyLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZCA+PSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBsYXN0ID0gbGFzdCAmJiBwYWQgPD0gMDtcbiAgICB2YXIgYmxvY2sgPSBlbmNyeXB0UmVjb3JkKGtleSwgY291bnRlciwgYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkUGFkLCBoZWFkZXIsIGxhc3QpO1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgYmxvY2tdKTtcblxuICAgIHN0YXJ0ID0gZW5kO1xuICAgICsrY291bnRlcjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Yob2JqZWN0KSA9PT0gJ2Z1bmN0aW9uJztcbiB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNyeXB0OiBkZWNyeXB0LFxuICBlbmNyeXB0OiBlbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsInJlcXVpcmUiLCJBRVNfR0NNIiwiUEFEX1NJWkUiLCJUQUdfTEVOR1RIIiwiS0VZX0xFTkdUSCIsIk5PTkNFX0xFTkdUSCIsIlNIQV8yNTZfTEVOR1RIIiwiTU9ERV9FTkNSWVBUIiwiTU9ERV9ERUNSWVBUIiwia2V5bG9nIiwicHJvY2VzcyIsImVudiIsIkVDRV9LRVlMT0ciLCJtIiwiayIsImNvbnNvbGUiLCJ3YXJuIiwibGVuZ3RoIiwidG9TdHJpbmciLCJkZWNvZGUiLCJiIiwiQnVmZmVyIiwiZnJvbSIsIkhNQUNfaGFzaCIsImtleSIsImlucHV0IiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJ1cGRhdGUiLCJkaWdlc3QiLCJIS0RGX2V4dHJhY3QiLCJzYWx0IiwiaWttIiwiSEtERl9leHBhbmQiLCJwcmsiLCJpbmZvIiwibCIsIm91dHB1dCIsImFsbG9jIiwiVCIsImNvdW50ZXIiLCJjYnVmIiwid3JpdGVVSW50QkUiLCJjb25jYXQiLCJzbGljZSIsIkhLREYiLCJsZW4iLCJiYXNlIiwiY29udGV4dCIsInJlc3VsdCIsImxlbmd0aFByZWZpeCIsImJ1ZmZlciIsImV4dHJhY3RESCIsImhlYWRlciIsIm1vZGUiLCJwcml2YXRlS2V5Iiwic2VuZGVyUHViS2V5IiwicmVjZWl2ZXJQdWJLZXkiLCJnZXRQdWJsaWNLZXkiLCJkaCIsIkVycm9yIiwic2VjcmV0IiwiY29tcHV0ZVNlY3JldCIsImtleWxhYmVsIiwiZXh0cmFjdFNlY3JldEFuZENvbnRleHQiLCJrZXlpZCIsInVuZGVmaW5lZCIsImtleW1hcCIsImF1dGhTZWNyZXQiLCJ3ZWJwdXNoU2VjcmV0IiwicmVtb3RlUHViS2V5IiwiZXh0cmFjdFNlY3JldCIsImtleUxvb2t1cENhbGxiYWNrIiwiaXNGdW5jdGlvbiIsImRlcml2ZUtleUFuZE5vbmNlIiwibG9va3VwS2V5Q2FsbGJhY2siLCJ2ZXJzaW9uIiwia2V5SW5mbyIsIm5vbmNlSW5mbyIsInMiLCJub25jZSIsInBhcnNlUGFyYW1zIiwicGFyYW1zIiwicnMiLCJwYXJzZUludCIsImlzTmFOIiwib3ZlcmhlYWQiLCJnZW5lcmF0ZU5vbmNlIiwicmVhZFVJbnRCRSIsIngiLCJyZWFkSGVhZGVyIiwiaWRzeiIsInVucGFkTGVnYWN5IiwiZGF0YSIsInBhZFNpemUiLCJwYWQiLCJwYWRDaGVjayIsImZpbGwiLCJjb21wYXJlIiwidW5wYWQiLCJsYXN0IiwiaSIsImRlY3J5cHRSZWNvcmQiLCJnY20iLCJjcmVhdGVEZWNpcGhlcml2Iiwic2V0QXV0aFRhZyIsImZpbmFsIiwiZGVjcnlwdCIsImhlYWRlckxlbmd0aCIsInN0YXJ0IiwiY2h1bmtTaXplIiwiZW5kIiwiTWF0aCIsIm1pbiIsImJsb2NrIiwiZW5jcnlwdFJlY29yZCIsImNyZWF0ZUNpcGhlcml2IiwiY2lwaGVydGV4dCIsInBhZGRpbmciLCJwdXNoIiwidGFnIiwiZ2V0QXV0aFRhZyIsIndyaXRlSGVhZGVyIiwiaW50cyIsImVuY3J5cHQiLCJpc0J1ZmZlciIsInJhbmRvbUJ5dGVzIiwicmVjb3JkUGFkIiwib2JqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http_ece/ece.js\n");

/***/ })

};
;