"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-push";
exports.ids = ["vendor-chunks/web-push"];
exports.modules = {

/***/ "(rsc)/./node_modules/web-push/src/encryption-helper.js":
/*!********************************************************!*\
  !*** ./node_modules/web-push/src/encryption-helper.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst ece = __webpack_require__(/*! http_ece */ \"(rsc)/./node_modules/http_ece/ece.js\");\nconst encrypt = function(userPublicKey, userAuth, payload, contentEncoding) {\n    if (!userPublicKey) {\n        throw new Error(\"No user public key provided for encryption.\");\n    }\n    if (typeof userPublicKey !== \"string\") {\n        throw new Error(\"The subscription p256dh value must be a string.\");\n    }\n    if (Buffer.from(userPublicKey, \"base64url\").length !== 65) {\n        throw new Error(\"The subscription p256dh value should be 65 bytes long.\");\n    }\n    if (!userAuth) {\n        throw new Error(\"No user auth provided for encryption.\");\n    }\n    if (typeof userAuth !== \"string\") {\n        throw new Error(\"The subscription auth key must be a string.\");\n    }\n    if (Buffer.from(userAuth, \"base64url\").length < 16) {\n        throw new Error(\"The subscription auth key should be at least 16 \" + \"bytes long\");\n    }\n    if (typeof payload !== \"string\" && !Buffer.isBuffer(payload)) {\n        throw new Error(\"Payload must be either a string or a Node Buffer.\");\n    }\n    if (typeof payload === \"string\" || payload instanceof String) {\n        payload = Buffer.from(payload);\n    }\n    const localCurve = crypto.createECDH(\"prime256v1\");\n    const localPublicKey = localCurve.generateKeys();\n    const salt = crypto.randomBytes(16).toString(\"base64url\");\n    const cipherText = ece.encrypt(payload, {\n        version: contentEncoding,\n        dh: userPublicKey,\n        privateKey: localCurve,\n        salt: salt,\n        authSecret: userAuth\n    });\n    return {\n        localPublicKey: localPublicKey,\n        salt: salt,\n        cipherText: cipherText\n    };\n};\nmodule.exports = {\n    encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL2VuY3J5cHRpb24taGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFFcEIsTUFBTUUsVUFBVSxTQUFTQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxlQUFlO0lBQ3hFLElBQUksQ0FBQ0gsZUFBZTtRQUNsQixNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxJQUFJLE9BQU9KLGtCQUFrQixVQUFVO1FBQ3JDLE1BQU0sSUFBSUksTUFBTTtJQUNsQjtJQUVBLElBQUlDLE9BQU9DLElBQUksQ0FBQ04sZUFBZSxhQUFhTyxNQUFNLEtBQUssSUFBSTtRQUN6RCxNQUFNLElBQUlILE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNILFVBQVU7UUFDYixNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFFQSxJQUFJLE9BQU9ILGFBQWEsVUFBVTtRQUNoQyxNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFFQSxJQUFJQyxPQUFPQyxJQUFJLENBQUNMLFVBQVUsYUFBYU0sTUFBTSxHQUFHLElBQUk7UUFDbEQsTUFBTSxJQUFJSCxNQUFNLHFEQUNkO0lBQ0o7SUFFQSxJQUFJLE9BQU9GLFlBQVksWUFBWSxDQUFDRyxPQUFPRyxRQUFRLENBQUNOLFVBQVU7UUFDNUQsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsSUFBSSxPQUFPRixZQUFZLFlBQVlBLG1CQUFtQk8sUUFBUTtRQUM1RFAsVUFBVUcsT0FBT0MsSUFBSSxDQUFDSjtJQUN4QjtJQUVBLE1BQU1RLGFBQWFkLE9BQU9lLFVBQVUsQ0FBQztJQUNyQyxNQUFNQyxpQkFBaUJGLFdBQVdHLFlBQVk7SUFFOUMsTUFBTUMsT0FBT2xCLE9BQU9tQixXQUFXLENBQUMsSUFBSUMsUUFBUSxDQUFDO0lBRTdDLE1BQU1DLGFBQWFuQixJQUFJQyxPQUFPLENBQUNHLFNBQVM7UUFDdENnQixTQUFTZjtRQUNUZ0IsSUFBSW5CO1FBQ0pvQixZQUFZVjtRQUNaSSxNQUFNQTtRQUNOTyxZQUFZcEI7SUFDZDtJQUVBLE9BQU87UUFDTFcsZ0JBQWdCQTtRQUNoQkUsTUFBTUE7UUFDTkcsWUFBWUE7SUFDZDtBQUNGO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUNmeEIsU0FBU0E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2dvZ2dpbnMtYWktY29hY2gvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL2VuY3J5cHRpb24taGVscGVyLmpzP2FhN2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGVjZSA9IHJlcXVpcmUoJ2h0dHBfZWNlJyk7XG5cbmNvbnN0IGVuY3J5cHQgPSBmdW5jdGlvbih1c2VyUHVibGljS2V5LCB1c2VyQXV0aCwgcGF5bG9hZCwgY29udGVudEVuY29kaW5nKSB7XG4gIGlmICghdXNlclB1YmxpY0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBwdWJsaWMga2V5IHByb3ZpZGVkIGZvciBlbmNyeXB0aW9uLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1c2VyUHVibGljS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBwMjU2ZGggdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuZnJvbSh1c2VyUHVibGljS2V5LCAnYmFzZTY0dXJsJykubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBwMjU2ZGggdmFsdWUgc2hvdWxkIGJlIDY1IGJ5dGVzIGxvbmcuJyk7XG4gIH1cblxuICBpZiAoIXVzZXJBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGF1dGggcHJvdmlkZWQgZm9yIGVuY3J5cHRpb24uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHVzZXJBdXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBhdXRoIGtleSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5mcm9tKHVzZXJBdXRoLCAnYmFzZTY0dXJsJykubGVuZ3RoIDwgMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJzY3JpcHRpb24gYXV0aCBrZXkgc2hvdWxkIGJlIGF0IGxlYXN0IDE2ICdcbiAgICArICdieXRlcyBsb25nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheWxvYWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBOb2RlIEJ1ZmZlci4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgcGF5bG9hZCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHBheWxvYWQgPSBCdWZmZXIuZnJvbShwYXlsb2FkKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsQ3VydmUgPSBjcnlwdG8uY3JlYXRlRUNESCgncHJpbWUyNTZ2MScpO1xuICBjb25zdCBsb2NhbFB1YmxpY0tleSA9IGxvY2FsQ3VydmUuZ2VuZXJhdGVLZXlzKCk7XG5cbiAgY29uc3Qgc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuXG4gIGNvbnN0IGNpcGhlclRleHQgPSBlY2UuZW5jcnlwdChwYXlsb2FkLCB7XG4gICAgdmVyc2lvbjogY29udGVudEVuY29kaW5nLFxuICAgIGRoOiB1c2VyUHVibGljS2V5LFxuICAgIHByaXZhdGVLZXk6IGxvY2FsQ3VydmUsXG4gICAgc2FsdDogc2FsdCxcbiAgICBhdXRoU2VjcmV0OiB1c2VyQXV0aFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGxvY2FsUHVibGljS2V5OiBsb2NhbFB1YmxpY0tleSxcbiAgICBzYWx0OiBzYWx0LFxuICAgIGNpcGhlclRleHQ6IGNpcGhlclRleHRcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0OiBlbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsInJlcXVpcmUiLCJlY2UiLCJlbmNyeXB0IiwidXNlclB1YmxpY0tleSIsInVzZXJBdXRoIiwicGF5bG9hZCIsImNvbnRlbnRFbmNvZGluZyIsIkVycm9yIiwiQnVmZmVyIiwiZnJvbSIsImxlbmd0aCIsImlzQnVmZmVyIiwiU3RyaW5nIiwibG9jYWxDdXJ2ZSIsImNyZWF0ZUVDREgiLCJsb2NhbFB1YmxpY0tleSIsImdlbmVyYXRlS2V5cyIsInNhbHQiLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwiY2lwaGVyVGV4dCIsInZlcnNpb24iLCJkaCIsInByaXZhdGVLZXkiLCJhdXRoU2VjcmV0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/encryption-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/web-push/src/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(rsc)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(rsc)/./node_modules/web-push/src/encryption-helper.js\");\nconst WebPushLib = __webpack_require__(/*! ./web-push-lib.js */ \"(rsc)/./node_modules/web-push/src/web-push-lib.js\");\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(rsc)/./node_modules/web-push/src/web-push-error.js\");\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\nconst webPush = new WebPushLib();\nmodule.exports = {\n    WebPushError: WebPushError,\n    supportedContentEncodings: WebPushConstants.supportedContentEncodings,\n    encrypt: encryptionHelper.encrypt,\n    getVapidHeaders: vapidHelper.getVapidHeaders,\n    generateVAPIDKeys: vapidHelper.generateVAPIDKeys,\n    setGCMAPIKey: webPush.setGCMAPIKey,\n    setVapidDetails: webPush.setVapidDetails,\n    generateRequestDetails: webPush.generateRequestDetails,\n    sendNotification: webPush.sendNotification.bind(webPush)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsY0FBY0MsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQztBQUNqQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNSSxtQkFBbUJKLG1CQUFPQSxDQUFDO0FBRWpDLE1BQU1LLFVBQVUsSUFBSUg7QUFFcEJJLE9BQU9DLE9BQU8sR0FBRztJQUNmSixjQUFjQTtJQUNkSywyQkFBMkJKLGlCQUFpQkkseUJBQXlCO0lBQ3JFQyxTQUFTUixpQkFBaUJRLE9BQU87SUFDakNDLGlCQUFpQlgsWUFBWVcsZUFBZTtJQUM1Q0MsbUJBQW1CWixZQUFZWSxpQkFBaUI7SUFDaERDLGNBQWNQLFFBQVFPLFlBQVk7SUFDbENDLGlCQUFpQlIsUUFBUVEsZUFBZTtJQUN4Q0Msd0JBQXdCVCxRQUFRUyxzQkFBc0I7SUFDdERDLGtCQUFrQlYsUUFBUVUsZ0JBQWdCLENBQUNDLElBQUksQ0FBQ1g7QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nb2dnaW5zLWFpLWNvYWNoLy4vbm9kZV9tb2R1bGVzL3dlYi1wdXNoL3NyYy9pbmRleC5qcz80ZWIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdmFwaWRIZWxwZXIgPSByZXF1aXJlKCcuL3ZhcGlkLWhlbHBlci5qcycpO1xuY29uc3QgZW5jcnlwdGlvbkhlbHBlciA9IHJlcXVpcmUoJy4vZW5jcnlwdGlvbi1oZWxwZXIuanMnKTtcbmNvbnN0IFdlYlB1c2hMaWIgPSByZXF1aXJlKCcuL3dlYi1wdXNoLWxpYi5qcycpO1xuY29uc3QgV2ViUHVzaEVycm9yID0gcmVxdWlyZSgnLi93ZWItcHVzaC1lcnJvci5qcycpO1xuY29uc3QgV2ViUHVzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtY29uc3RhbnRzLmpzJyk7XG5cbmNvbnN0IHdlYlB1c2ggPSBuZXcgV2ViUHVzaExpYigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViUHVzaEVycm9yOiBXZWJQdXNoRXJyb3IsXG4gIHN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3M6IFdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyxcbiAgZW5jcnlwdDogZW5jcnlwdGlvbkhlbHBlci5lbmNyeXB0LFxuICBnZXRWYXBpZEhlYWRlcnM6IHZhcGlkSGVscGVyLmdldFZhcGlkSGVhZGVycyxcbiAgZ2VuZXJhdGVWQVBJREtleXM6IHZhcGlkSGVscGVyLmdlbmVyYXRlVkFQSURLZXlzLFxuICBzZXRHQ01BUElLZXk6IHdlYlB1c2guc2V0R0NNQVBJS2V5LFxuICBzZXRWYXBpZERldGFpbHM6IHdlYlB1c2guc2V0VmFwaWREZXRhaWxzLFxuICBnZW5lcmF0ZVJlcXVlc3REZXRhaWxzOiB3ZWJQdXNoLmdlbmVyYXRlUmVxdWVzdERldGFpbHMsXG4gIHNlbmROb3RpZmljYXRpb246IHdlYlB1c2guc2VuZE5vdGlmaWNhdGlvbi5iaW5kKHdlYlB1c2gpXG59O1xuIl0sIm5hbWVzIjpbInZhcGlkSGVscGVyIiwicmVxdWlyZSIsImVuY3J5cHRpb25IZWxwZXIiLCJXZWJQdXNoTGliIiwiV2ViUHVzaEVycm9yIiwiV2ViUHVzaENvbnN0YW50cyIsIndlYlB1c2giLCJtb2R1bGUiLCJleHBvcnRzIiwic3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyIsImVuY3J5cHQiLCJnZXRWYXBpZEhlYWRlcnMiLCJnZW5lcmF0ZVZBUElES2V5cyIsInNldEdDTUFQSUtleSIsInNldFZhcGlkRGV0YWlscyIsImdlbmVyYXRlUmVxdWVzdERldGFpbHMiLCJzZW5kTm90aWZpY2F0aW9uIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js":
/*!************************************************************!*\
  !*** ./node_modules/web-push/src/urlsafe-base64-helper.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n/**\n * @param {string} base64\n * @returns {boolean}\n */ function validate(base64) {\n    return /^[A-Za-z0-9\\-_]+$/.test(base64);\n}\nmodule.exports = {\n    validate: validate\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3VybHNhZmUtYmFzZTY0LWhlbHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNBLFNBQVNDLE1BQU07SUFDdEIsT0FBTyxvQkFBb0JDLElBQUksQ0FBQ0Q7QUFDbEM7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZKLFVBQVVBO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nb2dnaW5zLWFpLWNvYWNoLy4vbm9kZV9tb2R1bGVzL3dlYi1wdXNoL3NyYy91cmxzYWZlLWJhc2U2NC1oZWxwZXIuanM/NWY5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKGJhc2U2NCkge1xuICByZXR1cm4gL15bQS1aYS16MC05XFwtX10rJC8udGVzdChiYXNlNjQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xuIl0sIm5hbWVzIjpbInZhbGlkYXRlIiwiYmFzZTY0IiwidGVzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/vapid-helper.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/vapid-helper.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst asn1 = __webpack_require__(/*! asn1.js */ \"(rsc)/./node_modules/asn1.js/lib/asn1.js\");\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */ const DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\nconst ECPrivateKeyASN = asn1.define(\"ECPrivateKey\", function() {\n    this.seq().obj(this.key(\"version\").int(), this.key(\"privateKey\").octstr(), this.key(\"parameters\").explicit(0).objid().optional(), this.key(\"publicKey\").explicit(1).bitstr().optional());\n});\nfunction toPEM(key) {\n    return ECPrivateKeyASN.encode({\n        version: 1,\n        privateKey: key,\n        parameters: [\n            1,\n            2,\n            840,\n            10045,\n            3,\n            1,\n            7\n        ] // prime256v1\n    }, \"pem\", {\n        label: \"EC PRIVATE KEY\"\n    });\n}\nfunction generateVAPIDKeys() {\n    const curve = crypto.createECDH(\"prime256v1\");\n    curve.generateKeys();\n    let publicKeyBuffer = curve.getPublicKey();\n    let privateKeyBuffer = curve.getPrivateKey();\n    // Occassionally the keys will not be padded to the correct lengh resulting\n    // in errors, hence this padding.\n    // See https://github.com/web-push-libs/web-push/issues/295 for history.\n    if (privateKeyBuffer.length < 32) {\n        const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n        padding.fill(0);\n        privateKeyBuffer = Buffer.concat([\n            padding,\n            privateKeyBuffer\n        ]);\n    }\n    if (publicKeyBuffer.length < 65) {\n        const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n        padding.fill(0);\n        publicKeyBuffer = Buffer.concat([\n            padding,\n            publicKeyBuffer\n        ]);\n    }\n    return {\n        publicKey: publicKeyBuffer.toString(\"base64url\"),\n        privateKey: privateKeyBuffer.toString(\"base64url\")\n    };\n}\nfunction validateSubject(subject) {\n    if (!subject) {\n        throw new Error(\"No subject set in vapidDetails.subject.\");\n    }\n    if (typeof subject !== \"string\" || subject.length === 0) {\n        throw new Error(\"The subject value must be a string containing an https: URL or \" + \"mailto: address. \" + subject);\n    }\n    let subjectParseResult = null;\n    try {\n        subjectParseResult = new URL(subject);\n    } catch (err) {\n        throw new Error(\"Vapid subject is not a valid URL. \" + subject);\n    }\n    if (![\n        \"https:\",\n        \"mailto:\"\n    ].includes(subjectParseResult.protocol)) {\n        throw new Error(\"Vapid subject is not an https: or mailto: URL. \" + subject);\n    }\n    if (subjectParseResult.hostname === \"localhost\") {\n        console.warn(\"Vapid subject points to a localhost web URI, which is unsupported by \" + \"Apple's push notification server and will result in a BadJwtToken error when \" + \"sending notifications.\");\n    }\n}\nfunction validatePublicKey(publicKey) {\n    if (!publicKey) {\n        throw new Error(\"No key set vapidDetails.publicKey\");\n    }\n    if (typeof publicKey !== \"string\") {\n        throw new Error(\"Vapid public key is must be a URL safe Base 64 \" + \"encoded string.\");\n    }\n    if (!urlBase64Helper.validate(publicKey)) {\n        throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n    }\n    publicKey = Buffer.from(publicKey, \"base64url\");\n    if (publicKey.length !== 65) {\n        throw new Error(\"Vapid public key should be 65 bytes long when decoded.\");\n    }\n}\nfunction validatePrivateKey(privateKey) {\n    if (!privateKey) {\n        throw new Error(\"No key set in vapidDetails.privateKey\");\n    }\n    if (typeof privateKey !== \"string\") {\n        throw new Error(\"Vapid private key must be a URL safe Base 64 \" + \"encoded string.\");\n    }\n    if (!urlBase64Helper.validate(privateKey)) {\n        throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n    }\n    privateKey = Buffer.from(privateKey, \"base64url\");\n    if (privateKey.length !== 32) {\n        throw new Error(\"Vapid private key should be 32 bytes long when decoded.\");\n    }\n}\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */ function getFutureExpirationTimestamp(numSeconds) {\n    const futureExp = new Date();\n    futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n    return Math.floor(futureExp.getTime() / 1000);\n}\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */ function validateExpiration(expiration) {\n    if (!Number.isInteger(expiration)) {\n        throw new Error(\"`expiration` value must be a number\");\n    }\n    if (expiration < 0) {\n        throw new Error(\"`expiration` must be a positive integer\");\n    }\n    // Roughly checks the time of expiration, since the max expiration can be ahead\n    // of the time than at the moment the expiration was generated\n    const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n    if (expiration >= maxExpirationTimestamp) {\n        throw new Error(\"`expiration` value is greater than maximum of 24 hours\");\n    }\n}\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */ function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n    if (!audience) {\n        throw new Error(\"No audience could be generated for VAPID.\");\n    }\n    if (typeof audience !== \"string\" || audience.length === 0) {\n        throw new Error(\"The audience value must be a string containing the \" + \"origin of a push service. \" + audience);\n    }\n    try {\n        new URL(audience); // eslint-disable-line no-new\n    } catch (err) {\n        throw new Error(\"VAPID audience is not a url. \" + audience);\n    }\n    validateSubject(subject);\n    validatePublicKey(publicKey);\n    validatePrivateKey(privateKey);\n    privateKey = Buffer.from(privateKey, \"base64url\");\n    if (expiration) {\n        validateExpiration(expiration);\n    } else {\n        expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n    }\n    const header = {\n        typ: \"JWT\",\n        alg: \"ES256\"\n    };\n    const jwtPayload = {\n        aud: audience,\n        exp: expiration,\n        sub: subject\n    };\n    const jwt = jws.sign({\n        header: header,\n        payload: jwtPayload,\n        privateKey: toPEM(privateKey)\n    });\n    if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n        return {\n            Authorization: \"vapid t=\" + jwt + \", k=\" + publicKey\n        };\n    }\n    if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n        return {\n            Authorization: \"WebPush \" + jwt,\n            \"Crypto-Key\": \"p256ecdsa=\" + publicKey\n        };\n    }\n    throw new Error(\"Unsupported encoding type specified.\");\n}\nmodule.exports = {\n    generateVAPIDKeys: generateVAPIDKeys,\n    getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n    getVapidHeaders: getVapidHeaders,\n    validateSubject: validateSubject,\n    validatePublicKey: validatePublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validateExpiration: validateExpiration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3ZhcGlkLWhlbHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRUcsR0FBRyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1JLG1CQUFtQkosbUJBQU9BLENBQUM7QUFDakMsTUFBTUssa0JBQWtCTCxtQkFBT0EsQ0FBQztBQUVoQzs7Q0FFQyxHQUNELE1BQU1NLDZCQUE2QixLQUFLLEtBQUs7QUFFN0MsNkRBQTZEO0FBQzdELE1BQU1DLHlCQUF5QixLQUFLLEtBQUs7QUFFekMsTUFBTUMsa0JBQWtCUCxLQUFLUSxNQUFNLENBQUMsZ0JBQWdCO0lBQ2xELElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxHQUFHLENBQ1osSUFBSSxDQUFDQyxHQUFHLENBQUMsV0FBV0MsR0FBRyxJQUN2QixJQUFJLENBQUNELEdBQUcsQ0FBQyxjQUFjRSxNQUFNLElBQzdCLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGNBQWNHLFFBQVEsQ0FBQyxHQUFHQyxLQUFLLEdBQ3JDQyxRQUFRLElBQ1gsSUFBSSxDQUFDTCxHQUFHLENBQUMsYUFBYUcsUUFBUSxDQUFDLEdBQUdHLE1BQU0sR0FDckNELFFBQVE7QUFFZjtBQUVBLFNBQVNFLE1BQU1QLEdBQUc7SUFDaEIsT0FBT0osZ0JBQWdCWSxNQUFNLENBQUM7UUFDNUJDLFNBQVM7UUFDVEMsWUFBWVY7UUFDWlcsWUFBWTtZQUFDO1lBQUc7WUFBRztZQUFLO1lBQU87WUFBRztZQUFHO1NBQUUsQ0FBQyxhQUFhO0lBQ3ZELEdBQUcsT0FBTztRQUNSQyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLFNBQVNDO0lBQ1AsTUFBTUMsUUFBUTNCLE9BQU80QixVQUFVLENBQUM7SUFDaENELE1BQU1FLFlBQVk7SUFFbEIs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QUlpRCxvQkFBb0JuRSxpQkFBaUI4RSx5QkFBeUIsQ0FBQ0MsV0FBVyxFQUFFO1FBQzlFLE9BQU87WUFDTEMsZUFBZSxhQUFhTCxNQUFNLFNBQVN4QztRQUM3QztJQUNGO0lBQ0EsSUFBSWdDLG9CQUFvQm5FLGlCQUFpQjhFLHlCQUF5QixDQUFDRyxPQUFPLEVBQUU7UUFDMUUsT0FBTztZQUNMRCxlQUFlLGFBQWFMO1lBQzVCLGNBQWMsZUFBZXhDO1FBQy9CO0lBQ0Y7SUFFQSxNQUFNLElBQUlJLE1BQU07QUFDbEI7QUFFQTJDLE9BQU9DLE9BQU8sR0FBRztJQUNmOUQsbUJBQW1CQTtJQUNuQjhCLDhCQUE4QkE7SUFDOUJjLGlCQUFpQkE7SUFDakI1QixpQkFBaUJBO0lBQ2pCVSxtQkFBbUJBO0lBQ25CRyxvQkFBb0JBO0lBQ3BCVSxvQkFBb0JBO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29nZ2lucy1haS1jb2FjaC8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvdmFwaWQtaGVscGVyLmpzPzg0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJyk7XG5jb25zdCBqd3MgPSByZXF1aXJlKCdqd3MnKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgV2ViUHVzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtY29uc3RhbnRzLmpzJyk7XG5jb25zdCB1cmxCYXNlNjRIZWxwZXIgPSByZXF1aXJlKCcuL3VybHNhZmUtYmFzZTY0LWhlbHBlcicpO1xuXG4vKipcbiAqIERFRkFVTFRfRVhQSVJBVElPTiBpcyBzZXQgdG8gc2Vjb25kcyBpbiAxMiBob3Vyc1xuICovXG5jb25zdCBERUZBVUxUX0VYUElSQVRJT05fU0VDT05EUyA9IDEyICogNjAgKiA2MDtcblxuLy8gTWF4aW11bSBleHBpcmF0aW9uIGlzIDI0IGhvdXJzIGFjY29yZGluZy4gKFNlZSBWQVBJRCBzcGVjKVxuY29uc3QgTUFYX0VYUElSQVRJT05fU0VDT05EUyA9IDI0ICogNjAgKiA2MDtcblxuY29uc3QgRUNQcml2YXRlS2V5QVNOID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlS2V5Jykub2N0c3RyKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5leHBsaWNpdCgwKS5vYmppZCgpXG4gICAgICAub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5JykuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgICAgIC5vcHRpb25hbCgpXG4gICk7XG59KTtcblxuZnVuY3Rpb24gdG9QRU0oa2V5KSB7XG4gIHJldHVybiBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHByaXZhdGVLZXk6IGtleSxcbiAgICBwYXJhbWV0ZXJzOiBbMSwgMiwgODQwLCAxMDA0NSwgMywgMSwgN10gLy8gcHJpbWUyNTZ2MVxuICB9LCAncGVtJywge1xuICAgIGxhYmVsOiAnRUMgUFJJVkFURSBLRVknXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVZBUElES2V5cygpIHtcbiAgY29uc3QgY3VydmUgPSBjcnlwdG8uY3JlYXRlRUNESCgncHJpbWUyNTZ2MScpO1xuICBjdXJ2ZS5nZW5lcmF0ZUtleXMoKTtcblxuICBsZXQgcHVibGljS2V5QnVmZmVyID0gY3VydmUuZ2V0UHVibGljS2V5KCk7XG4gIGxldCBwcml2YXRlS2V5QnVmZmVyID0gY3VydmUuZ2V0UHJpdmF0ZUtleSgpO1xuXG4gIC8vIE9jY2Fzc2lvbmFsbHkgdGhlIGtleXMgd2lsbCBub3QgYmUgcGFkZGVkIHRvIHRoZSBjb3JyZWN0IGxlbmdoIHJlc3VsdGluZ1xuICAvLyBpbiBlcnJvcnMsIGhlbmNlIHRoaXMgcGFkZGluZy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcHVzaC1saWJzL3dlYi1wdXNoL2lzc3Vlcy8yOTUgZm9yIGhpc3RvcnkuXG4gIGlmIChwcml2YXRlS2V5QnVmZmVyLmxlbmd0aCA8IDMyKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IEJ1ZmZlci5hbGxvYygzMiAtIHByaXZhdGVLZXlCdWZmZXIubGVuZ3RoKTtcbiAgICBwYWRkaW5nLmZpbGwoMCk7XG4gICAgcHJpdmF0ZUtleUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3BhZGRpbmcsIHByaXZhdGVLZXlCdWZmZXJdKTtcbiAgfVxuXG4gIGlmIChwdWJsaWNLZXlCdWZmZXIubGVuZ3RoIDwgNjUpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gQnVmZmVyLmFsbG9jKDY1IC0gcHVibGljS2V5QnVmZmVyLmxlbmd0aCk7XG4gICAgcGFkZGluZy5maWxsKDApO1xuICAgIHB1YmxpY0tleUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3BhZGRpbmcsIHB1YmxpY0tleUJ1ZmZlcl0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleUJ1ZmZlci50b1N0cmluZygnYmFzZTY0dXJsJyksXG4gICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUJ1ZmZlci50b1N0cmluZygnYmFzZTY0dXJsJylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpIHtcbiAgaWYgKCFzdWJqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWJqZWN0IHNldCBpbiB2YXBpZERldGFpbHMuc3ViamVjdC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3ViamVjdCAhPT0gJ3N0cmluZycgfHwgc3ViamVjdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJqZWN0IHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBhbiBodHRwczogVVJMIG9yICdcbiAgICArICdtYWlsdG86IGFkZHJlc3MuICcgKyBzdWJqZWN0KTtcbiAgfVxuXG4gIGxldCBzdWJqZWN0UGFyc2VSZXN1bHQgPSBudWxsO1xuICB0cnkge1xuICAgIHN1YmplY3RQYXJzZVJlc3VsdCA9IG5ldyBVUkwoc3ViamVjdCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgc3ViamVjdCBpcyBub3QgYSB2YWxpZCBVUkwuICcgKyBzdWJqZWN0KTtcbiAgfVxuICBpZiAoIVsnaHR0cHM6JywgJ21haWx0bzonXS5pbmNsdWRlcyhzdWJqZWN0UGFyc2VSZXN1bHQucHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBzdWJqZWN0IGlzIG5vdCBhbiBodHRwczogb3IgbWFpbHRvOiBVUkwuICcgKyBzdWJqZWN0KTtcbiAgfVxuICBpZiAoc3ViamVjdFBhcnNlUmVzdWx0Lmhvc3RuYW1lID09PSAnbG9jYWxob3N0Jykge1xuICAgIGNvbnNvbGUud2FybignVmFwaWQgc3ViamVjdCBwb2ludHMgdG8gYSBsb2NhbGhvc3Qgd2ViIFVSSSwgd2hpY2ggaXMgdW5zdXBwb3J0ZWQgYnkgJ1xuICAgICAgKyAnQXBwbGVcXCdzIHB1c2ggbm90aWZpY2F0aW9uIHNlcnZlciBhbmQgd2lsbCByZXN1bHQgaW4gYSBCYWRKd3RUb2tlbiBlcnJvciB3aGVuICdcbiAgICAgICsgJ3NlbmRpbmcgbm90aWZpY2F0aW9ucy4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleSkge1xuICBpZiAoIXB1YmxpY0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5IHNldCB2YXBpZERldGFpbHMucHVibGljS2V5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHB1YmxpY0tleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHB1YmxpYyBrZXkgaXMgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgJ1xuICAgICsgJ2VuY29kZWQgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKCF1cmxCYXNlNjRIZWxwZXIudmFsaWRhdGUocHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHVibGljIGtleSBtdXN0IGJlIGEgVVJMIHNhZmUgQmFzZSA2NCAod2l0aG91dCBcIj1cIiknKTtcbiAgfVxuXG4gIHB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHB1YmxpY0tleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHVibGljIGtleSBzaG91bGQgYmUgNjUgYnl0ZXMgbG9uZyB3aGVuIGRlY29kZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBrZXkgc2V0IGluIHZhcGlkRGV0YWlscy5wcml2YXRlS2V5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByaXZhdGVLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBwcml2YXRlIGtleSBtdXN0IGJlIGEgVVJMIHNhZmUgQmFzZSA2NCAnXG4gICAgKyAnZW5jb2RlZCBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoIXVybEJhc2U2NEhlbHBlci52YWxpZGF0ZShwcml2YXRlS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHJpdmF0ZSBrZXkgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgKHdpdGhvdXQgXCI9XCIpJyk7XG4gIH1cblxuICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHByaXZhdGUga2V5IHNob3VsZCBiZSAzMiBieXRlcyBsb25nIHdoZW4gZGVjb2RlZC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBjYWxjdWxhdGVzXG4gKiB0aGUgZXhwaXJhdGlvbiBpbiB0aGUgZnV0dXJlIGJ5IGFkZGluZyB0aGUgcGFzc2VkIGBudW1TZWNvbmRzYFxuICogd2l0aCB0aGUgY3VycmVudCBzZWNvbmRzIGZyb20gVW5peCBFcG9jaFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWNvbmRzIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEZ1dHVyZSBleHBpcmF0aW9uIGluIHNlY29uZHNcbiAqL1xuZnVuY3Rpb24gZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcChudW1TZWNvbmRzKSB7XG4gIGNvbnN0IGZ1dHVyZUV4cCA9IG5ldyBEYXRlKCk7XG4gIGZ1dHVyZUV4cC5zZXRTZWNvbmRzKGZ1dHVyZUV4cC5nZXRTZWNvbmRzKCkgKyBudW1TZWNvbmRzKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZnV0dXJlRXhwLmdldFRpbWUoKSAvIDEwMDApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgRXhwaXJhdGlvbiBIZWFkZXIgYmFzZWQgb24gdGhlIFZBUElEIFNwZWNcbiAqIFRocm93cyBlcnJvciBvZiB0eXBlIGBFcnJvcmAgaWYgdGhlIGV4cGlyYXRpb24gaXMgbm90IHZhbGlkYXRlZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBleHBpcmF0aW9uIEV4cGlyYXRpb24gc2Vjb25kcyBmcm9tIEVwb2NoIHRvIGJlIHZhbGlkYXRlZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGlyYXRpb24oZXhwaXJhdGlvbikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoZXhwaXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHBpcmF0aW9uYCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZXhwaXJhdGlvbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHBpcmF0aW9uYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgLy8gUm91Z2hseSBjaGVja3MgdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiwgc2luY2UgdGhlIG1heCBleHBpcmF0aW9uIGNhbiBiZSBhaGVhZFxuICAvLyBvZiB0aGUgdGltZSB0aGFuIGF0IHRoZSBtb21lbnQgdGhlIGV4cGlyYXRpb24gd2FzIGdlbmVyYXRlZFxuICBjb25zdCBtYXhFeHBpcmF0aW9uVGltZXN0YW1wID0gZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcChNQVhfRVhQSVJBVElPTl9TRUNPTkRTKTtcblxuICBpZiAoZXhwaXJhdGlvbiA+PSBtYXhFeHBpcmF0aW9uVGltZXN0YW1wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJhdGlvbmAgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1heGltdW0gb2YgMjQgaG91cnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIHRoZSByZXF1aXJlZCBWQVBJRCBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIHRoZSByZXF1aXJlZFxuICogaGVhZGVyIHRvIGJlIGFkZGVkIHRvIGEgV2ViIFB1c2ggUHJvdG9jb2wgUmVxdWVzdC5cbiAqIEBwYXJhbSAge3N0cmluZ30gYXVkaWVuY2UgICAgICAgIFRoaXMgbXVzdCBiZSB0aGUgb3JpZ2luIG9mIHRoZSBwdXNoIHNlcnZpY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN1YmplY3QgICAgICAgICBUaGlzIHNob3VsZCBiZSBhIFVSTCBvciBhICdtYWlsdG86JyBlbWFpbFxuICogYWRkcmVzcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gcHVibGljS2V5ICAgICAgIFRoZSBWQVBJRCBwdWJsaWMga2V5LlxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5ICAgICAgVGhlIFZBUElEIHByaXZhdGUga2V5LlxuICogQHBhcmFtICB7c3RyaW5nfSBjb250ZW50RW5jb2RpbmcgVGhlIGNvbnRlbnRFbmNvZGluZyB0eXBlLlxuICogQHBhcmFtICB7aW50ZWdlcn0gW2V4cGlyYXRpb25dICAgVGhlIGV4cGlyYXRpb24gb2YgdGhlIFZBUElEIEpXVC5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgIFJldHVybnMgYW4gT2JqZWN0IHdpdGggdGhlIEF1dGhvcml6YXRpb24gYW5kXG4gKiAnQ3J5cHRvLUtleScgdmFsdWVzIHRvIGJlIHVzZWQgYXMgaGVhZGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFwaWRIZWFkZXJzKGF1ZGllbmNlLCBzdWJqZWN0LCBwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbnRlbnRFbmNvZGluZywgZXhwaXJhdGlvbikge1xuICBpZiAoIWF1ZGllbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdWRpZW5jZSBjb3VsZCBiZSBnZW5lcmF0ZWQgZm9yIFZBUElELicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdWRpZW5jZSAhPT0gJ3N0cmluZycgfHwgYXVkaWVuY2UubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXVkaWVuY2UgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIHRoZSAnXG4gICAgKyAnb3JpZ2luIG9mIGEgcHVzaCBzZXJ2aWNlLiAnICsgYXVkaWVuY2UpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBuZXcgVVJMKGF1ZGllbmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWQVBJRCBhdWRpZW5jZSBpcyBub3QgYSB1cmwuICcgKyBhdWRpZW5jZSk7XG4gIH1cblxuICB2YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCk7XG4gIHZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleSk7XG4gIHZhbGlkYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcblxuICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChleHBpcmF0aW9uKSB7XG4gICAgdmFsaWRhdGVFeHBpcmF0aW9uKGV4cGlyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGV4cGlyYXRpb24gPSBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wKERFRkFVTFRfRVhQSVJBVElPTl9TRUNPTkRTKTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICB0eXA6ICdKV1QnLFxuICAgIGFsZzogJ0VTMjU2J1xuICB9O1xuXG4gIGNvbnN0IGp3dFBheWxvYWQgPSB7XG4gICAgYXVkOiBhdWRpZW5jZSxcbiAgICBleHA6IGV4cGlyYXRpb24sXG4gICAgc3ViOiBzdWJqZWN0XG4gIH07XG5cbiAgY29uc3Qgand0ID0gandzLnNpZ24oe1xuICAgIGhlYWRlcjogaGVhZGVyLFxuICAgIHBheWxvYWQ6IGp3dFBheWxvYWQsXG4gICAgcHJpdmF0ZUtleTogdG9QRU0ocHJpdmF0ZUtleSlcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gV2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246ICd2YXBpZCB0PScgKyBqd3QgKyAnLCBrPScgKyBwdWJsaWNLZXlcbiAgICB9O1xuICB9XG4gIGlmIChjb250ZW50RW5jb2RpbmcgPT09IFdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfR0NNKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246ICdXZWJQdXNoICcgKyBqd3QsXG4gICAgICAnQ3J5cHRvLUtleSc6ICdwMjU2ZWNkc2E9JyArIHB1YmxpY0tleVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY29kaW5nIHR5cGUgc3BlY2lmaWVkLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2VuZXJhdGVWQVBJREtleXM6IGdlbmVyYXRlVkFQSURLZXlzLFxuICBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wOiBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wLFxuICBnZXRWYXBpZEhlYWRlcnM6IGdldFZhcGlkSGVhZGVycyxcbiAgdmFsaWRhdGVTdWJqZWN0OiB2YWxpZGF0ZVN1YmplY3QsXG4gIHZhbGlkYXRlUHVibGljS2V5OiB2YWxpZGF0ZVB1YmxpY0tleSxcbiAgdmFsaWRhdGVQcml2YXRlS2V5OiB2YWxpZGF0ZVByaXZhdGVLZXksXG4gIHZhbGlkYXRlRXhwaXJhdGlvbjogdmFsaWRhdGVFeHBpcmF0aW9uXG59O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsInJlcXVpcmUiLCJhc24xIiwiandzIiwiVVJMIiwiV2ViUHVzaENvbnN0YW50cyIsInVybEJhc2U2NEhlbHBlciIsIkRFRkFVTFRfRVhQSVJBVElPTl9TRUNPTkRTIiwiTUFYX0VYUElSQVRJT05fU0VDT05EUyIsIkVDUHJpdmF0ZUtleUFTTiIsImRlZmluZSIsInNlcSIsIm9iaiIsImtleSIsImludCIsIm9jdHN0ciIsImV4cGxpY2l0Iiwib2JqaWQiLCJvcHRpb25hbCIsImJpdHN0ciIsInRvUEVNIiwiZW5jb2RlIiwidmVyc2lvbiIsInByaXZhdGVLZXkiLCJwYXJhbWV0ZXJzIiwibGFiZWwiLCJnZW5lcmF0ZVZBUElES2V5cyIsImN1cnZlIiwiY3JlYXRlRUNESCIsImdlbmVyYXRlS2V5cyIsInB1YmxpY0tleUJ1ZmZlciIsImdldFB1YmxpY0tleSIsInByaXZhdGVLZXlCdWZmZXIiLCJnZXRQcml2YXRlS2V5IiwibGVuZ3RoIiwicGFkZGluZyIsIkJ1ZmZlciIsImFsbG9jIiwiZmlsbCIsImNvbmNhdCIsInB1YmxpY0tleSIsInRvU3RyaW5nIiwidmFsaWRhdGVTdWJqZWN0Iiwic3ViamVjdCIsIkVycm9yIiwic3ViamVjdFBhcnNlUmVzdWx0IiwiZXJyIiwiaW5jbHVkZXMiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwiY29uc29sZSIsIndhcm4iLCJ2YWxpZGF0ZVB1YmxpY0tleSIsInZhbGlkYXRlIiwiZnJvbSIsInZhbGlkYXRlUHJpdmF0ZUtleSIsImdldEZ1dHVyZUV4cGlyYXRpb25UaW1lc3RhbXAiLCJudW1TZWNvbmRzIiwiZnV0dXJlRXhwIiwiRGF0ZSIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwiTWF0aCIsImZsb29yIiwiZ2V0VGltZSIsInZhbGlkYXRlRXhwaXJhdGlvbiIsImV4cGlyYXRpb24iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYXhFeHBpcmF0aW9uVGltZXN0YW1wIiwiZ2V0VmFwaWRIZWFkZXJzIiwiYXVkaWVuY2UiLCJjb250ZW50RW5jb2RpbmciLCJoZWFkZXIiLCJ0eXAiLCJhbGciLCJqd3RQYXlsb2FkIiwiYXVkIiwiZXhwIiwic3ViIiwiand0Iiwic2lnbiIsInBheWxvYWQiLCJzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzIiwiQUVTXzEyOF9HQ00iLCJBdXRob3JpemF0aW9uIiwiQUVTX0dDTSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/vapid-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/web-push/src/web-push-constants.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nconst WebPushConstants = {};\nWebPushConstants.supportedContentEncodings = {\n    AES_GCM: \"aesgcm\",\n    AES_128_GCM: \"aes128gcm\"\n};\nWebPushConstants.supportedUrgency = {\n    VERY_LOW: \"very-low\",\n    LOW: \"low\",\n    NORMAL: \"normal\",\n    HIGH: \"high\"\n};\nmodule.exports = WebPushConstants;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWNvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLG1CQUFtQixDQUFDO0FBRTFCQSxpQkFBaUJDLHlCQUF5QixHQUFHO0lBQzNDQyxTQUFTO0lBQ1RDLGFBQWE7QUFDZjtBQUVBSCxpQkFBaUJJLGdCQUFnQixHQUFHO0lBQ2xDQyxVQUFVO0lBQ1ZDLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxNQUFNO0FBQ1I7QUFFQUMsT0FBT0MsT0FBTyxHQUFHViIsInNvdXJjZXMiOlsid2VicGFjazovL2dvZ2dpbnMtYWktY29hY2gvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWNvbnN0YW50cy5qcz83NzVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViUHVzaENvbnN0YW50cyA9IHt9O1xuXG5XZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MgPSB7XG4gIEFFU19HQ006ICdhZXNnY20nLFxuICBBRVNfMTI4X0dDTTogJ2FlczEyOGdjbSdcbn07XG5cbldlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeSA9IHtcbiAgVkVSWV9MT1c6ICd2ZXJ5LWxvdycsXG4gIExPVzogJ2xvdycsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG4gIEhJR0g6ICdoaWdoJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJQdXNoQ29uc3RhbnRzO1xuIl0sIm5hbWVzIjpbIldlYlB1c2hDb25zdGFudHMiLCJzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzIiwiQUVTX0dDTSIsIkFFU18xMjhfR0NNIiwic3VwcG9ydGVkVXJnZW5jeSIsIlZFUllfTE9XIiwiTE9XIiwiTk9STUFMIiwiSElHSCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-error.js":
/*!*****************************************************!*\
  !*** ./node_modules/web-push/src/web-push-error.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction WebPushError(message, statusCode, headers, body, endpoint) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.statusCode = statusCode;\n    this.headers = headers;\n    this.body = body;\n    this.endpoint = endpoint;\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(WebPushError, Error);\nmodule.exports = WebPushError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsYUFBYUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ2hFQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxXQUFXO0lBRTlDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0QsV0FBVyxDQUFDQyxJQUFJO0lBQ2pDLElBQUksQ0FBQ1IsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7QUFDbEI7QUFFQUssa0RBQXdCLENBQUNWLGNBQWNNO0FBRXZDTSxPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29nZ2lucy1haS1jb2FjaC8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvd2ViLXB1c2gtZXJyb3IuanM/MWI2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFdlYlB1c2hFcnJvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5LCBlbmRwb2ludCkge1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcblxuICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbn1cblxucmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKFdlYlB1c2hFcnJvciwgRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlB1c2hFcnJvcjtcbiJdLCJuYW1lcyI6WyJXZWJQdXNoRXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJib2R5IiwiZW5kcG9pbnQiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwicmVxdWlyZSIsImluaGVyaXRzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-lib.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/web-push-lib.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst url = __webpack_require__(/*! url */ \"url\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(rsc)/./node_modules/web-push/src/web-push-error.js\");\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(rsc)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(rsc)/./node_modules/web-push/src/encryption-helper.js\");\nconst webPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\nlet gcmAPIKey = \"\";\nlet vapidDetails;\nfunction WebPushLib() {}\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */ WebPushLib.prototype.setGCMAPIKey = function(apiKey) {\n    if (apiKey === null) {\n        gcmAPIKey = null;\n        return;\n    }\n    if (typeof apiKey === \"undefined\" || typeof apiKey !== \"string\" || apiKey.length === 0) {\n        throw new Error(\"The GCM API Key should be a non-empty string or null.\");\n    }\n    gcmAPIKey = apiKey;\n};\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */ WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {\n    if (arguments.length === 1 && arguments[0] === null) {\n        vapidDetails = null;\n        return;\n    }\n    vapidHelper.validateSubject(subject);\n    vapidHelper.validatePublicKey(publicKey);\n    vapidHelper.validatePrivateKey(privateKey);\n    vapidDetails = {\n        subject: subject,\n        publicKey: publicKey,\n        privateKey: privateKey\n    };\n};\n/**\n   * To get the details of a request to trigger a push message, without sending\n   * a push notification call this method.\n   *\n   * This method will throw an error if there is an issue with the input.\n   * @param  {PushSubscription} subscription The PushSubscription you wish to\n   * send the notification to.\n   * @param  {string|Buffer} [payload]       The payload you wish to send to the\n   * the user.\n   * @param  {Object} [options]              Options for the GCM API key and\n   * vapid keys can be passed in if they are unique for each notification you\n   * wish to send.\n   * @return {Object}                       This method returns an Object which\n   * contains 'endpoint', 'method', 'headers' and 'payload'.\n   */ WebPushLib.prototype.generateRequestDetails = function(subscription, payload, options) {\n    if (!subscription || !subscription.endpoint) {\n        throw new Error(\"You must pass in a subscription with at least \" + \"an endpoint.\");\n    }\n    if (typeof subscription.endpoint !== \"string\" || subscription.endpoint.length === 0) {\n        throw new Error(\"The subscription endpoint must be a string with \" + \"a valid URL.\");\n    }\n    if (payload) {\n        // Validate the subscription keys\n        if (typeof subscription !== \"object\" || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {\n            throw new Error(\"To send a message with a payload, the \" + \"subscription must have 'auth' and 'p256dh' keys.\");\n        }\n    }\n    let currentGCMAPIKey = gcmAPIKey;\n    let currentVapidDetails = vapidDetails;\n    let timeToLive = DEFAULT_TTL;\n    let extraHeaders = {};\n    let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    let urgency = webPushConstants.supportedUrgency.NORMAL;\n    let topic;\n    let proxy;\n    let agent;\n    let timeout;\n    if (options) {\n        const validOptionKeys = [\n            \"headers\",\n            \"gcmAPIKey\",\n            \"vapidDetails\",\n            \"TTL\",\n            \"contentEncoding\",\n            \"urgency\",\n            \"topic\",\n            \"proxy\",\n            \"agent\",\n            \"timeout\"\n        ];\n        const optionKeys = Object.keys(options);\n        for(let i = 0; i < optionKeys.length; i += 1){\n            const optionKey = optionKeys[i];\n            if (!validOptionKeys.includes(optionKey)) {\n                throw new Error(\"'\" + optionKey + \"' is an invalid option. \" + \"The valid options are ['\" + validOptionKeys.join(\"', '\") + \"'].\");\n            }\n        }\n        if (options.headers) {\n            extraHeaders = options.headers;\n            let duplicates = Object.keys(extraHeaders).filter(function(header) {\n                return typeof options[header] !== \"undefined\";\n            });\n            if (duplicates.length > 0) {\n                throw new Error(\"Duplicated headers defined [\" + duplicates.join(\",\") + \"]. Please either define the header in the\" + \"top level options OR in the 'headers' key.\");\n            }\n        }\n        if (options.gcmAPIKey) {\n            currentGCMAPIKey = options.gcmAPIKey;\n        }\n        // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n        if (options.vapidDetails !== undefined) {\n            currentVapidDetails = options.vapidDetails;\n        }\n        if (options.TTL !== undefined) {\n            timeToLive = Number(options.TTL);\n            if (timeToLive < 0) {\n                throw new Error(\"TTL should be a number and should be at least 0\");\n            }\n        }\n        if (options.contentEncoding) {\n            if (options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n                contentEncoding = options.contentEncoding;\n            } else {\n                throw new Error(\"Unsupported content encoding specified.\");\n            }\n        }\n        if (options.urgency) {\n            if (options.urgency === webPushConstants.supportedUrgency.VERY_LOW || options.urgency === webPushConstants.supportedUrgency.LOW || options.urgency === webPushConstants.supportedUrgency.NORMAL || options.urgency === webPushConstants.supportedUrgency.HIGH) {\n                urgency = options.urgency;\n            } else {\n                throw new Error(\"Unsupported urgency specified.\");\n            }\n        }\n        if (options.topic) {\n            if (!urlBase64Helper.validate(options.topic)) {\n                throw new Error(\"Unsupported characters set use the URL or filename-safe Base64 characters set\");\n            }\n            if (options.topic.length > 32) {\n                throw new Error(\"use maximum of 32 characters from the URL or filename-safe Base64 characters set\");\n            }\n            topic = options.topic;\n        }\n        if (options.proxy) {\n            if (typeof options.proxy === \"string\" || typeof options.proxy.host === \"string\") {\n                proxy = options.proxy;\n            } else {\n                console.warn(\"Attempt to use proxy option, but invalid type it should be a string or proxy options object.\");\n            }\n        }\n        if (options.agent) {\n            if (options.agent instanceof https.Agent) {\n                if (proxy) {\n                    console.warn(\"Agent option will be ignored because proxy option is defined.\");\n                }\n                agent = options.agent;\n            } else {\n                console.warn(\"Wrong type for the agent option, it should be an instance of https.Agent.\");\n            }\n        }\n        if (typeof options.timeout === \"number\") {\n            timeout = options.timeout;\n        }\n    }\n    if (typeof timeToLive === \"undefined\") {\n        timeToLive = DEFAULT_TTL;\n    }\n    const requestDetails = {\n        method: \"POST\",\n        headers: {\n            TTL: timeToLive\n        }\n    };\n    Object.keys(extraHeaders).forEach(function(header) {\n        requestDetails.headers[header] = extraHeaders[header];\n    });\n    let requestPayload = null;\n    if (payload) {\n        const encrypted = encryptionHelper.encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n        requestDetails.headers[\"Content-Length\"] = encrypted.cipherText.length;\n        requestDetails.headers[\"Content-Type\"] = \"application/octet-stream\";\n        if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n            requestDetails.headers[\"Content-Encoding\"] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n        } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n            requestDetails.headers[\"Content-Encoding\"] = webPushConstants.supportedContentEncodings.AES_GCM;\n            requestDetails.headers.Encryption = \"salt=\" + encrypted.salt;\n            requestDetails.headers[\"Crypto-Key\"] = \"dh=\" + encrypted.localPublicKey.toString(\"base64url\");\n        }\n        requestPayload = encrypted.cipherText;\n    } else {\n        requestDetails.headers[\"Content-Length\"] = 0;\n    }\n    const isGCM = subscription.endpoint.startsWith(\"https://android.googleapis.com/gcm/send\");\n    const isFCM = subscription.endpoint.startsWith(\"https://fcm.googleapis.com/fcm/send\");\n    // VAPID isn't supported by GCM hence the if, else if.\n    if (isGCM) {\n        if (!currentGCMAPIKey) {\n            console.warn(\"Attempt to send push notification to GCM endpoint, \" + \"but no GCM key is defined. Please use setGCMApiKey() or add \" + \"'gcmAPIKey' as an option.\");\n        } else {\n            requestDetails.headers.Authorization = \"key=\" + currentGCMAPIKey;\n        }\n    } else if (currentVapidDetails) {\n        const parsedUrl = url.parse(subscription.endpoint);\n        const audience = parsedUrl.protocol + \"//\" + parsedUrl.host;\n        const vapidHeaders = vapidHelper.getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);\n        requestDetails.headers.Authorization = vapidHeaders.Authorization;\n        if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n            if (requestDetails.headers[\"Crypto-Key\"]) {\n                requestDetails.headers[\"Crypto-Key\"] += \";\" + vapidHeaders[\"Crypto-Key\"];\n            } else {\n                requestDetails.headers[\"Crypto-Key\"] = vapidHeaders[\"Crypto-Key\"];\n            }\n        }\n    } else if (isFCM && currentGCMAPIKey) {\n        requestDetails.headers.Authorization = \"key=\" + currentGCMAPIKey;\n    }\n    requestDetails.headers.Urgency = urgency;\n    if (topic) {\n        requestDetails.headers.Topic = topic;\n    }\n    requestDetails.body = requestPayload;\n    requestDetails.endpoint = subscription.endpoint;\n    if (proxy) {\n        requestDetails.proxy = proxy;\n    }\n    if (agent) {\n        requestDetails.agent = agent;\n    }\n    if (timeout) {\n        requestDetails.timeout = timeout;\n    }\n    return requestDetails;\n};\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */ WebPushLib.prototype.sendNotification = function(subscription, payload, options) {\n    let requestDetails;\n    try {\n        requestDetails = this.generateRequestDetails(subscription, payload, options);\n    } catch (err) {\n        return Promise.reject(err);\n    }\n    return new Promise(function(resolve, reject) {\n        const httpsOptions = {};\n        const urlParts = url.parse(requestDetails.endpoint);\n        httpsOptions.hostname = urlParts.hostname;\n        httpsOptions.port = urlParts.port;\n        httpsOptions.path = urlParts.path;\n        httpsOptions.headers = requestDetails.headers;\n        httpsOptions.method = requestDetails.method;\n        if (requestDetails.timeout) {\n            httpsOptions.timeout = requestDetails.timeout;\n        }\n        if (requestDetails.agent) {\n            httpsOptions.agent = requestDetails.agent;\n        }\n        if (requestDetails.proxy) {\n            const { HttpsProxyAgent } = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\"); // eslint-disable-line global-require\n            httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n        }\n        const pushRequest = https.request(httpsOptions, function(pushResponse) {\n            let responseText = \"\";\n            pushResponse.on(\"data\", function(chunk) {\n                responseText += chunk;\n            });\n            pushResponse.on(\"end\", function() {\n                if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n                    reject(new WebPushError(\"Received unexpected response code\", pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));\n                } else {\n                    resolve({\n                        statusCode: pushResponse.statusCode,\n                        body: responseText,\n                        headers: pushResponse.headers\n                    });\n                }\n            });\n        });\n        if (requestDetails.timeout) {\n            pushRequest.on(\"timeout\", function() {\n                pushRequest.destroy(new Error(\"Socket timeout\"));\n            });\n        }\n        pushRequest.on(\"error\", function(e) {\n            reject(e);\n        });\n        if (requestDetails.body) {\n            pushRequest.write(requestDetails.body);\n        }\n        pushRequest.end();\n    });\n};\nmodule.exports = WebPushLib;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWxpYi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1JLG1CQUFtQkosbUJBQU9BLENBQUM7QUFDakMsTUFBTUssbUJBQW1CTCxtQkFBT0EsQ0FBQztBQUNqQyxNQUFNTSxrQkFBa0JOLG1CQUFPQSxDQUFDO0FBRWhDLDZCQUE2QjtBQUM3QixNQUFNTyxjQUFjO0FBRXBCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUM7QUFFSixTQUFTQyxjQUVUO0FBRUE7Ozs7O0NBS0MsR0FDREEsV0FBV0MsU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBU0MsTUFBTTtJQUNqRCxJQUFJQSxXQUFXLE1BQU07UUFDbkJMLFlBQVk7UUFDWjtJQUNGO0lBRUEsSUFBSSxPQUFPSyxXQUFXLGVBQ25CLE9BQU9BLFdBQVcsWUFDbEJBLE9BQU9DLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBUCxZQUFZSztBQUNkO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RILFdBQVdDLFNBQVMsQ0FBQ0ssZUFBZSxHQUFHLFNBQVNDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxVQUFVO0lBQzFFLElBQUlDLFVBQVVOLE1BQU0sS0FBSyxLQUFLTSxTQUFTLENBQUMsRUFBRSxLQUFLLE1BQU07UUFDbkRYLGVBQWU7UUFDZjtJQUNGO0lBRUFOLFlBQVlrQixlQUFlLENBQUNKO0lBQzVCZCxZQUFZbUIsaUJBQWlCLENBQUNKO0lBQzlCZixZQUFZb0Isa0JBQWtCLENBQUNKO0lBRS9CVixlQUFlO1FBQ2JRLFNBQVNBO1FBQ1RDLFdBQVdBO1FBQ1hDLFlBQVlBO0lBQ2Q7QUFDRjtBQUVBOzs7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QUFJO1FBQ3ZDO1FBRUFZLFlBQVlVLEdBQUc7SUFDakI7QUFDRjtBQUVGQyxPQUFPQyxPQUFPLEdBQUcxRyIsInNvdXJjZXMiOlsid2VicGFjazovL2dvZ2dpbnMtYWktY29hY2gvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWxpYi5qcz8zZjNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbmNvbnN0IFdlYlB1c2hFcnJvciA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtZXJyb3IuanMnKTtcbmNvbnN0IHZhcGlkSGVscGVyID0gcmVxdWlyZSgnLi92YXBpZC1oZWxwZXIuanMnKTtcbmNvbnN0IGVuY3J5cHRpb25IZWxwZXIgPSByZXF1aXJlKCcuL2VuY3J5cHRpb24taGVscGVyLmpzJyk7XG5jb25zdCB3ZWJQdXNoQ29uc3RhbnRzID0gcmVxdWlyZSgnLi93ZWItcHVzaC1jb25zdGFudHMuanMnKTtcbmNvbnN0IHVybEJhc2U2NEhlbHBlciA9IHJlcXVpcmUoJy4vdXJsc2FmZS1iYXNlNjQtaGVscGVyJyk7XG5cbi8vIERlZmF1bHQgVFRMIGlzIGZvdXIgd2Vla3MuXG5jb25zdCBERUZBVUxUX1RUTCA9IDI0MTkyMDA7XG5cbmxldCBnY21BUElLZXkgPSAnJztcbmxldCB2YXBpZERldGFpbHM7XG5cbmZ1bmN0aW9uIFdlYlB1c2hMaWIoKSB7XG5cbn1cblxuLyoqXG4gKiBXaGVuIHNlbmRpbmcgbWVzc2FnZXMgdG8gYSBHQ00gZW5kcG9pbnQgeW91IG5lZWQgdG8gc2V0IHRoZSBHQ00gQVBJIGtleVxuICogYnkgZWl0aGVyIGNhbGxpbmcgc2V0R01BUElLZXkoKSBvciBwYXNzaW5nIGluIHRoZSBBUEkga2V5IGFzIGFuIG9wdGlvblxuICogdG8gc2VuZE5vdGlmaWNhdGlvbigpLlxuICogQHBhcmFtICB7c3RyaW5nfSBhcGlLZXkgVGhlIEFQSSBrZXkgdG8gc2VuZCB3aXRoIHRoZSBHQ00gcmVxdWVzdC5cbiAqL1xuV2ViUHVzaExpYi5wcm90b3R5cGUuc2V0R0NNQVBJS2V5ID0gZnVuY3Rpb24oYXBpS2V5KSB7XG4gIGlmIChhcGlLZXkgPT09IG51bGwpIHtcbiAgICBnY21BUElLZXkgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSAndW5kZWZpbmVkJ1xuICB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJ1xuICB8fCBhcGlLZXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgR0NNIEFQSSBLZXkgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBudWxsLicpO1xuICB9XG5cbiAgZ2NtQVBJS2V5ID0gYXBpS2V5O1xufTtcblxuLyoqXG4gKiBXaGVuIG1ha2luZyByZXF1ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byBkZWZpbmUgVkFQSUQgZGV0YWlscywgY2FsbCB0aGlzXG4gKiBtZXRob2QgYmVmb3JlIHNlbmROb3RpZmljYXRpb24oKSBvciBwYXNzIGluIHRoZSBkZXRhaWxzIGFuZCBvcHRpb25zIHRvXG4gKiBzZW5kTm90aWZpY2F0aW9uLlxuICogQHBhcmFtICB7c3RyaW5nfSBzdWJqZWN0ICAgIFRoaXMgbXVzdCBiZSBlaXRoZXIgYSBVUkwgb3IgYSAnbWFpbHRvOidcbiAqIGFkZHJlc3MuIEZvciBleGFtcGxlOiAnaHR0cHM6Ly9teS1zaXRlLmNvbS9jb250YWN0JyBvclxuICogJ21haWx0bzogY29udGFjdEBteS1zaXRlLmNvbSdcbiAqIEBwYXJhbSAge3N0cmluZ30gcHVibGljS2V5ICBUaGUgcHVibGljIFZBUElEIGtleSwgYSBVUkwgc2FmZSwgYmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXkgVGhlIHByaXZhdGUgVkFQSUQga2V5LCBhIFVSTCBzYWZlLCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbldlYlB1c2hMaWIucHJvdG90eXBlLnNldFZhcGlkRGV0YWlscyA9IGZ1bmN0aW9uKHN1YmplY3QsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gbnVsbCkge1xuICAgICAgdmFwaWREZXRhaWxzID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXBpZEhlbHBlci52YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCk7XG4gICAgdmFwaWRIZWxwZXIudmFsaWRhdGVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB2YXBpZEhlbHBlci52YWxpZGF0ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG5cbiAgICB2YXBpZERldGFpbHMgPSB7XG4gICAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gZ2V0IHRoZSBkZXRhaWxzIG9mIGEgcmVxdWVzdCB0byB0cmlnZ2VyIGEgcHVzaCBtZXNzYWdlLCB3aXRob3V0IHNlbmRpbmdcbiAgICogYSBwdXNoIG5vdGlmaWNhdGlvbiBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGlzIGFuIGlzc3VlIHdpdGggdGhlIGlucHV0LlxuICAgKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdWJzY3JpcHRpb24geW91IHdpc2ggdG9cbiAgICogc2VuZCB0aGUgbm90aWZpY2F0aW9uIHRvLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfSBbcGF5bG9hZF0gICAgICAgVGhlIHBheWxvYWQgeW91IHdpc2ggdG8gc2VuZCB0byB0aGVcbiAgICogdGhlIHVzZXIuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdICAgICAgICAgICAgICBPcHRpb25zIGZvciB0aGUgR0NNIEFQSSBrZXkgYW5kXG4gICAqIHZhcGlkIGtleXMgY2FuIGJlIHBhc3NlZCBpbiBpZiB0aGV5IGFyZSB1bmlxdWUgZm9yIGVhY2ggbm90aWZpY2F0aW9uIHlvdVxuICAgKiB3aXNoIHRvIHNlbmQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gT2JqZWN0IHdoaWNoXG4gICAqIGNvbnRhaW5zICdlbmRwb2ludCcsICdtZXRob2QnLCAnaGVhZGVycycgYW5kICdwYXlsb2FkJy5cbiAgICovXG5XZWJQdXNoTGliLnByb3RvdHlwZS5nZW5lcmF0ZVJlcXVlc3REZXRhaWxzID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24gfHwgIXN1YnNjcmlwdGlvbi5lbmRwb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGluIGEgc3Vic2NyaXB0aW9uIHdpdGggYXQgbGVhc3QgJ1xuICAgICAgKyAnYW4gZW5kcG9pbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uZW5kcG9pbnQgIT09ICdzdHJpbmcnXG4gICAgfHwgc3Vic2NyaXB0aW9uLmVuZHBvaW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3Vic2NyaXB0aW9uIGVuZHBvaW50IG11c3QgYmUgYSBzdHJpbmcgd2l0aCAnXG4gICAgICArICdhIHZhbGlkIFVSTC4nKTtcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHN1YnNjcmlwdGlvbiBrZXlzXG4gICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiAhPT0gJ29iamVjdCcgfHwgIXN1YnNjcmlwdGlvbi5rZXlzXG4gICAgICB8fCAhc3Vic2NyaXB0aW9uLmtleXMucDI1NmRoXG4gICAgICB8fCAhc3Vic2NyaXB0aW9uLmtleXMuYXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNlbmQgYSBtZXNzYWdlIHdpdGggYSBwYXlsb2FkLCB0aGUgJ1xuICAgICAgICArICdzdWJzY3JpcHRpb24gbXVzdCBoYXZlIFxcJ2F1dGhcXCcgYW5kIFxcJ3AyNTZkaFxcJyBrZXlzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjdXJyZW50R0NNQVBJS2V5ID0gZ2NtQVBJS2V5O1xuICAgIGxldCBjdXJyZW50VmFwaWREZXRhaWxzID0gdmFwaWREZXRhaWxzO1xuICAgIGxldCB0aW1lVG9MaXZlID0gREVGQVVMVF9UVEw7XG4gICAgbGV0IGV4dHJhSGVhZGVycyA9IHt9O1xuICAgIGxldCBjb250ZW50RW5jb2RpbmcgPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTXzEyOF9HQ007XG4gICAgbGV0IHVyZ2VuY3kgPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuTk9STUFMO1xuICAgIGxldCB0b3BpYztcbiAgICBsZXQgcHJveHk7XG4gICAgbGV0IGFnZW50O1xuICAgIGxldCB0aW1lb3V0O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbGlkT3B0aW9uS2V5cyA9IFtcbiAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAnZ2NtQVBJS2V5JyxcbiAgICAgICAgJ3ZhcGlkRGV0YWlscycsXG4gICAgICAgICdUVEwnLFxuICAgICAgICAnY29udGVudEVuY29kaW5nJyxcbiAgICAgICAgJ3VyZ2VuY3knLFxuICAgICAgICAndG9waWMnLFxuICAgICAgICAncHJveHknLFxuICAgICAgICAnYWdlbnQnLFxuICAgICAgICAndGltZW91dCdcbiAgICAgIF07XG4gICAgICBjb25zdCBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbktleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uS2V5ID0gb3B0aW9uS2V5c1tpXTtcbiAgICAgICAgaWYgKCF2YWxpZE9wdGlvbktleXMuaW5jbHVkZXMob3B0aW9uS2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnJyArIG9wdGlvbktleSArICdcXCcgaXMgYW4gaW52YWxpZCBvcHRpb24uICdcbiAgICAgICAgICArICdUaGUgdmFsaWQgb3B0aW9ucyBhcmUgW1xcJycgKyB2YWxpZE9wdGlvbktleXMuam9pbignXFwnLCBcXCcnKVxuICAgICAgICAgICsgJ1xcJ10uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGxldCBkdXBsaWNhdGVzID0gT2JqZWN0LmtleXMoZXh0cmFIZWFkZXJzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uc1toZWFkZXJdICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZWQgaGVhZGVycyBkZWZpbmVkIFsnXG4gICAgICAgICAgKyBkdXBsaWNhdGVzLmpvaW4oJywnKSArICddLiBQbGVhc2UgZWl0aGVyIGRlZmluZSB0aGUgaGVhZGVyIGluIHRoZSdcbiAgICAgICAgICArICd0b3AgbGV2ZWwgb3B0aW9ucyBPUiBpbiB0aGUgXFwnaGVhZGVyc1xcJyBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZ2NtQVBJS2V5KSB7XG4gICAgICAgIGN1cnJlbnRHQ01BUElLZXkgPSBvcHRpb25zLmdjbUFQSUtleTtcbiAgICAgIH1cblxuICAgICAgLy8gRmFsc3kgdmFsdWVzIGFyZSBhbGxvd2VkIGhlcmUgc28gb25lIGNhbiBza2lwIFZhcGlkIGBlbHNlIGlmYCBiZWxvdyBhbmQgdXNlIEZDTVxuICAgICAgaWYgKG9wdGlvbnMudmFwaWREZXRhaWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscyA9IG9wdGlvbnMudmFwaWREZXRhaWxzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5UVEwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lVG9MaXZlID0gTnVtYmVyKG9wdGlvbnMuVFRMKTtcbiAgICAgICAgaWYgKHRpbWVUb0xpdmUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUVEwgc2hvdWxkIGJlIGEgbnVtYmVyIGFuZCBzaG91bGQgYmUgYXQgbGVhc3QgMCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRFbmNvZGluZykge1xuICAgICAgICBpZiAoKG9wdGlvbnMuY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTXzEyOF9HQ01cbiAgICAgICAgICB8fCBvcHRpb25zLmNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU19HQ00pKSB7XG4gICAgICAgICAgY29udGVudEVuY29kaW5nID0gb3B0aW9ucy5jb250ZW50RW5jb2Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb250ZW50IGVuY29kaW5nIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy51cmdlbmN5KSB7XG4gICAgICAgIGlmICgob3B0aW9ucy51cmdlbmN5ID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuVkVSWV9MT1dcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5MT1dcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5OT1JNQUxcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5ISUdIKSkge1xuICAgICAgICAgIHVyZ2VuY3kgPSBvcHRpb25zLnVyZ2VuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB1cmdlbmN5IHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b3BpYykge1xuICAgICAgICBpZiAoIXVybEJhc2U2NEhlbHBlci52YWxpZGF0ZShvcHRpb25zLnRvcGljKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBzZXQgdXNlIHRoZSBVUkwgb3IgZmlsZW5hbWUtc2FmZSBCYXNlNjQgY2hhcmFjdGVycyBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50b3BpYy5sZW5ndGggPiAzMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlIG1heGltdW0gb2YgMzIgY2hhcmFjdGVycyBmcm9tIHRoZSBVUkwgb3IgZmlsZW5hbWUtc2FmZSBCYXNlNjQgY2hhcmFjdGVycyBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0b3BpYyA9IG9wdGlvbnMudG9waWM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnByb3h5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm94eSA9PT0gJ3N0cmluZydcbiAgICAgICAgICB8fCB0eXBlb2Ygb3B0aW9ucy5wcm94eS5ob3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb3h5ID0gb3B0aW9ucy5wcm94eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0F0dGVtcHQgdG8gdXNlIHByb3h5IG9wdGlvbiwgYnV0IGludmFsaWQgdHlwZSBpdCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgcHJveHkgb3B0aW9ucyBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWdlbnQgaW5zdGFuY2VvZiBodHRwcy5BZ2VudCkge1xuICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZ2VudCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGJlY2F1c2UgcHJveHkgb3B0aW9uIGlzIGRlZmluZWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV3JvbmcgdHlwZSBmb3IgdGhlIGFnZW50IG9wdGlvbiwgaXQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIGh0dHBzLkFnZW50LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGltZVRvTGl2ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRpbWVUb0xpdmUgPSBERUZBVUxUX1RUTDtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0RGV0YWlscyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBUVEw6IHRpbWVUb0xpdmVcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKGV4dHJhSGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzW2hlYWRlcl0gPSBleHRyYUhlYWRlcnNbaGVhZGVyXTtcbiAgICB9KTtcbiAgICBsZXQgcmVxdWVzdFBheWxvYWQgPSBudWxsO1xuXG4gICAgaWYgKHBheWxvYWQpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRpb25IZWxwZXJcbiAgICAgICAgLmVuY3J5cHQoc3Vic2NyaXB0aW9uLmtleXMucDI1NmRoLCBzdWJzY3JpcHRpb24ua2V5cy5hdXRoLCBwYXlsb2FkLCBjb250ZW50RW5jb2RpbmcpO1xuXG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gZW5jcnlwdGVkLmNpcGhlclRleHQubGVuZ3RoO1xuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNKSB7XG4gICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NvbnRlbnQtRW5jb2RpbmcnXSA9IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfMTI4X0dDTTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTSkge1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUVuY29kaW5nJ10gPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTTtcbiAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5FbmNyeXB0aW9uID0gJ3NhbHQ9JyArIGVuY3J5cHRlZC5zYWx0O1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDcnlwdG8tS2V5J10gPSAnZGg9JyArIGVuY3J5cHRlZC5sb2NhbFB1YmxpY0tleS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RQYXlsb2FkID0gZW5jcnlwdGVkLmNpcGhlclRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGlzR0NNID0gc3Vic2NyaXB0aW9uLmVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vYW5kcm9pZC5nb29nbGVhcGlzLmNvbS9nY20vc2VuZCcpO1xuICAgIGNvbnN0IGlzRkNNID0gc3Vic2NyaXB0aW9uLmVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vZmNtLmdvb2dsZWFwaXMuY29tL2ZjbS9zZW5kJyk7XG4gICAgLy8gVkFQSUQgaXNuJ3Qgc3VwcG9ydGVkIGJ5IEdDTSBoZW5jZSB0aGUgaWYsIGVsc2UgaWYuXG4gICAgaWYgKGlzR0NNKSB7XG4gICAgICBpZiAoIWN1cnJlbnRHQ01BUElLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0IHRvIHNlbmQgcHVzaCBub3RpZmljYXRpb24gdG8gR0NNIGVuZHBvaW50LCAnXG4gICAgICAgICsgJ2J1dCBubyBHQ00ga2V5IGlzIGRlZmluZWQuIFBsZWFzZSB1c2Ugc2V0R0NNQXBpS2V5KCkgb3IgYWRkICdcbiAgICAgICAgKyAnXFwnZ2NtQVBJS2V5XFwnIGFzIGFuIG9wdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdrZXk9JyArIGN1cnJlbnRHQ01BUElLZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFwaWREZXRhaWxzKSB7XG4gICAgICBjb25zdCBwYXJzZWRVcmwgPSB1cmwucGFyc2Uoc3Vic2NyaXB0aW9uLmVuZHBvaW50KTtcbiAgICAgIGNvbnN0IGF1ZGllbmNlID0gcGFyc2VkVXJsLnByb3RvY29sICsgJy8vJ1xuICAgICAgKyBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgdmFwaWRIZWFkZXJzID0gdmFwaWRIZWxwZXIuZ2V0VmFwaWRIZWFkZXJzKFxuICAgICAgICBhdWRpZW5jZSxcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscy5zdWJqZWN0LFxuICAgICAgICBjdXJyZW50VmFwaWREZXRhaWxzLnB1YmxpY0tleSxcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscy5wcml2YXRlS2V5LFxuICAgICAgICBjb250ZW50RW5jb2RpbmdcbiAgICAgICk7XG5cbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHZhcGlkSGVhZGVycy5BdXRob3JpemF0aW9uO1xuXG4gICAgICBpZiAoY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTSkge1xuICAgICAgICBpZiAocmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddKSB7XG4gICAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddICs9ICc7J1xuICAgICAgICAgICsgdmFwaWRIZWFkZXJzWydDcnlwdG8tS2V5J107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddID0gdmFwaWRIZWFkZXJzWydDcnlwdG8tS2V5J107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRkNNICYmIGN1cnJlbnRHQ01BUElLZXkpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdrZXk9JyArIGN1cnJlbnRHQ01BUElLZXk7XG4gICAgfVxuXG4gICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5VcmdlbmN5ID0gdXJnZW5jeTtcblxuICAgIGlmICh0b3BpYykge1xuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5Ub3BpYyA9IHRvcGljO1xuICAgIH1cblxuICAgIHJlcXVlc3REZXRhaWxzLmJvZHkgPSByZXF1ZXN0UGF5bG9hZDtcbiAgICByZXF1ZXN0RGV0YWlscy5lbmRwb2ludCA9IHN1YnNjcmlwdGlvbi5lbmRwb2ludDtcblxuICAgIGlmIChwcm94eSkge1xuICAgICAgcmVxdWVzdERldGFpbHMucHJveHkgPSBwcm94eTtcbiAgICB9XG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmFnZW50ID0gYWdlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0RGV0YWlscztcbiAgfTtcblxuLyoqXG4gKiBUbyBzZW5kIGEgcHVzaCBub3RpZmljYXRpb24gY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGEgc3Vic2NyaXB0aW9uLCBvcHRpb25hbFxuICogcGF5bG9hZCBhbmQgYW55IG9wdGlvbnMuXG4gKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdWJzY3JpcHRpb24geW91IHdpc2ggdG9cbiAqIHNlbmQgdGhlIG5vdGlmaWNhdGlvbiB0by5cbiAqIEBwYXJhbSAge3N0cmluZ3xCdWZmZXJ9IFtwYXlsb2FkXSAgICAgICBUaGUgcGF5bG9hZCB5b3Ugd2lzaCB0byBzZW5kIHRvIHRoZVxuICogdGhlIHVzZXIuXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgdGhlIEdDTSBBUEkga2V5IGFuZFxuICogdmFwaWQga2V5cyBjYW4gYmUgcGFzc2VkIGluIGlmIHRoZXkgYXJlIHVuaXF1ZSBmb3IgZWFjaCBub3RpZmljYXRpb24geW91XG4gKiB3aXNoIHRvIHNlbmQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBtZXRob2QgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAqIHJlc29sdmVzIGlmIHRoZSBzZW5kaW5nIG9mIHRoZSBub3RpZmljYXRpb24gd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBpdFxuICogcmVqZWN0cy5cbiAqL1xuV2ViUHVzaExpYi5wcm90b3R5cGUuc2VuZE5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbiwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGxldCByZXF1ZXN0RGV0YWlscztcbiAgICB0cnkge1xuICAgICAgcmVxdWVzdERldGFpbHMgPSB0aGlzLmdlbmVyYXRlUmVxdWVzdERldGFpbHMoc3Vic2NyaXB0aW9uLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IGh0dHBzT3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgdXJsUGFydHMgPSB1cmwucGFyc2UocmVxdWVzdERldGFpbHMuZW5kcG9pbnQpO1xuICAgICAgaHR0cHNPcHRpb25zLmhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWU7XG4gICAgICBodHRwc09wdGlvbnMucG9ydCA9IHVybFBhcnRzLnBvcnQ7XG4gICAgICBodHRwc09wdGlvbnMucGF0aCA9IHVybFBhcnRzLnBhdGg7XG5cbiAgICAgIGh0dHBzT3B0aW9ucy5oZWFkZXJzID0gcmVxdWVzdERldGFpbHMuaGVhZGVycztcbiAgICAgIGh0dHBzT3B0aW9ucy5tZXRob2QgPSByZXF1ZXN0RGV0YWlscy5tZXRob2Q7XG5cbiAgICAgIGlmIChyZXF1ZXN0RGV0YWlscy50aW1lb3V0KSB7XG4gICAgICAgIGh0dHBzT3B0aW9ucy50aW1lb3V0ID0gcmVxdWVzdERldGFpbHMudGltZW91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3REZXRhaWxzLmFnZW50KSB7XG4gICAgICAgIGh0dHBzT3B0aW9ucy5hZ2VudCA9IHJlcXVlc3REZXRhaWxzLmFnZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMucHJveHkpIHtcbiAgICAgICAgY29uc3QgeyBIdHRwc1Byb3h5QWdlbnQgfSA9IHJlcXVpcmUoJ2h0dHBzLXByb3h5LWFnZW50Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICAgICAgaHR0cHNPcHRpb25zLmFnZW50ID0gbmV3IEh0dHBzUHJveHlBZ2VudChyZXF1ZXN0RGV0YWlscy5wcm94eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHB1c2hSZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChodHRwc09wdGlvbnMsIGZ1bmN0aW9uKHB1c2hSZXNwb25zZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gJyc7XG5cbiAgICAgICAgcHVzaFJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICByZXNwb25zZVRleHQgKz0gY2h1bms7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHB1c2hSZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFdlYlB1c2hFcnJvcihcbiAgICAgICAgICAgICAgJ1JlY2VpdmVkIHVuZXhwZWN0ZWQgcmVzcG9uc2UgY29kZScsXG4gICAgICAgICAgICAgIHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICBwdXNoUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICByZXF1ZXN0RGV0YWlscy5lbmRwb2ludFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBwdXNoUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBwdXNoUmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMudGltZW91dCkge1xuICAgICAgICBwdXNoUmVxdWVzdC5vbigndGltZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHB1c2hSZXF1ZXN0LmRlc3Ryb3kobmV3IEVycm9yKCdTb2NrZXQgdGltZW91dCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hSZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0RGV0YWlscy5ib2R5KSB7XG4gICAgICAgIHB1c2hSZXF1ZXN0LndyaXRlKHJlcXVlc3REZXRhaWxzLmJvZHkpO1xuICAgICAgfVxuXG4gICAgICBwdXNoUmVxdWVzdC5lbmQoKTtcbiAgICB9KTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJQdXNoTGliO1xuIl0sIm5hbWVzIjpbInVybCIsInJlcXVpcmUiLCJodHRwcyIsIldlYlB1c2hFcnJvciIsInZhcGlkSGVscGVyIiwiZW5jcnlwdGlvbkhlbHBlciIsIndlYlB1c2hDb25zdGFudHMiLCJ1cmxCYXNlNjRIZWxwZXIiLCJERUZBVUxUX1RUTCIsImdjbUFQSUtleSIsInZhcGlkRGV0YWlscyIsIldlYlB1c2hMaWIiLCJwcm90b3R5cGUiLCJzZXRHQ01BUElLZXkiLCJhcGlLZXkiLCJsZW5ndGgiLCJFcnJvciIsInNldFZhcGlkRGV0YWlscyIsInN1YmplY3QiLCJwdWJsaWNLZXkiLCJwcml2YXRlS2V5IiwiYXJndW1lbnRzIiwidmFsaWRhdGVTdWJqZWN0IiwidmFsaWRhdGVQdWJsaWNLZXkiLCJ2YWxpZGF0ZVByaXZhdGVLZXkiLCJnZW5lcmF0ZVJlcXVlc3REZXRhaWxzIiwic3Vic2NyaXB0aW9uIiwicGF5bG9hZCIsIm9wdGlvbnMiLCJlbmRwb2ludCIsImtleXMiLCJwMjU2ZGgiLCJhdXRoIiwiY3VycmVudEdDTUFQSUtleSIsImN1cnJlbnRWYXBpZERldGFpbHMiLCJ0aW1lVG9MaXZlIiwiZXh0cmFIZWFkZXJzIiwiY29udGVudEVuY29kaW5nIiwic3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyIsIkFFU18xMjhfR0NNIiwidXJnZW5jeSIsInN1cHBvcnRlZFVyZ2VuY3kiLCJOT1JNQUwiLCJ0b3BpYyIsInByb3h5IiwiYWdlbnQiLCJ0aW1lb3V0IiwidmFsaWRPcHRpb25LZXlzIiwib3B0aW9uS2V5cyIsIk9iamVjdCIsImkiLCJvcHRpb25LZXkiLCJpbmNsdWRlcyIsImpvaW4iLCJoZWFkZXJzIiwiZHVwbGljYXRlcyIsImZpbHRlciIsImhlYWRlciIsInVuZGVmaW5lZCIsIlRUTCIsIk51bWJlciIsIkFFU19HQ00iLCJWRVJZX0xPVyIsIkxPVyIsIkhJR0giLCJ2YWxpZGF0ZSIsImhvc3QiLCJjb25zb2xlIiwid2FybiIsIkFnZW50IiwicmVxdWVzdERldGFpbHMiLCJtZXRob2QiLCJmb3JFYWNoIiwicmVxdWVzdFBheWxvYWQiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0IiwiY2lwaGVyVGV4dCIsIkVuY3J5cHRpb24iLCJzYWx0IiwibG9jYWxQdWJsaWNLZXkiLCJ0b1N0cmluZyIsImlzR0NNIiwic3RhcnRzV2l0aCIsImlzRkNNIiwiQXV0aG9yaXphdGlvbiIsInBhcnNlZFVybCIsInBhcnNlIiwiYXVkaWVuY2UiLCJwcm90b2NvbCIsInZhcGlkSGVhZGVycyIsImdldFZhcGlkSGVhZGVycyIsIlVyZ2VuY3kiLCJUb3BpYyIsImJvZHkiLCJzZW5kTm90aWZpY2F0aW9uIiwiZXJyIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc29sdmUiLCJodHRwc09wdGlvbnMiLCJ1cmxQYXJ0cyIsImhvc3RuYW1lIiwicG9ydCIsInBhdGgiLCJIdHRwc1Byb3h5QWdlbnQiLCJwdXNoUmVxdWVzdCIsInJlcXVlc3QiLCJwdXNoUmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJvbiIsImNodW5rIiwic3RhdHVzQ29kZSIsImRlc3Ryb3kiLCJlIiwid3JpdGUiLCJlbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-lib.js\n");

/***/ })

};
;