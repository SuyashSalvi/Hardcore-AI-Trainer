"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29nZ2lucy1haS1jb2FjaC8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vcmVhY3QubWpzP2FjMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IFJlYWN0RXhwb3J0cywgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZHVjZXIsIHVzZUVmZmVjdCwgdXNlRGVidWdWYWx1ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmNvbnN0IHVzZVN0b3JlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gIHJldHVybiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yZSkgfHwgc3RvcmUgfHwgZ2V0RGVmYXVsdFN0b3JlKCk7XG59O1xuY29uc3QgUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlbixcbiAgc3RvcmVcbn0pID0+IHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYoKTtcbiAgaWYgKCFzdG9yZSAmJiAhc3RvcmVSZWYuY3VycmVudCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFN0b3JlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogc3RvcmUgfHwgc3RvcmVSZWYuY3VycmVudFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn07XG5cbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSkgPT4ge1xuICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn0pO1xuZnVuY3Rpb24gdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3QgW1t2YWx1ZUZyb21SZWR1Y2VyLCBzdG9yZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcl0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICBpZiAoT2JqZWN0LmlzKHByZXZbMF0sIG5leHRWYWx1ZSkgJiYgcHJldlsxXSA9PT0gc3RvcmUgJiYgcHJldlsyXSA9PT0gYXRvbSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV4dFZhbHVlLCBzdG9yZSwgYXRvbV07XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgKCkgPT4gW3N0b3JlLmdldChhdG9tKSwgc3RvcmUsIGF0b21dXG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChzdG9yZUZyb21SZWR1Y2VyICE9PSBzdG9yZSB8fCBhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcigpO1xuICAgIHZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YihhdG9tLCAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVyZW5kZXIsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVyZW5kZXIoKTtcbiAgICB9KTtcbiAgICByZXJlbmRlcigpO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfSwgW3N0b3JlLCBhdG9tLCBkZWxheV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIGlzUHJvbWlzZUxpa2UodmFsdWUpID8gdXNlKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuc2V0KGF0b20sIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW3N0b3JlLCBhdG9tXVxuICApO1xuICByZXR1cm4gc2V0QXRvbTtcbn1cblxuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpLFxuICAgIC8vIFdlIGRvIHdyb25nIHR5cGUgYXNzZXJ0aW9uIGhlcmUsIHdoaWNoIHJlc3VsdHMgaW4gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKVxuICBdO1xufVxuXG5leHBvcnQgeyBQcm92aWRlciwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0RXhwb3J0cyIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlQ2FsbGJhY2siLCJnZXREZWZhdWx0U3RvcmUiLCJjcmVhdGVTdG9yZSIsIlN0b3JlQ29udGV4dCIsInVzZVN0b3JlIiwib3B0aW9ucyIsInN0b3JlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN0b3JlUmVmIiwiY3VycmVudCIsInZhbHVlIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwidXNlIiwicHJvbWlzZSIsInN0YXR1cyIsInJlYXNvbiIsInYiLCJlIiwidXNlQXRvbVZhbHVlIiwiYXRvbSIsInZhbHVlRnJvbVJlZHVjZXIiLCJzdG9yZUZyb21SZWR1Y2VyIiwiYXRvbUZyb21SZWR1Y2VyIiwicmVyZW5kZXIiLCJwcmV2IiwibmV4dFZhbHVlIiwiZ2V0IiwiT2JqZWN0IiwiaXMiLCJkZWxheSIsInVuc3ViIiwic3ViIiwic2V0VGltZW91dCIsInVzZVNldEF0b20iLCJzZXRBdG9tIiwiYXJncyIsImVudiIsIk1PREUiLCJFcnJvciIsInNldCIsInVzZUF0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = function(get) {\n            return get(this);\n        };\n        config.write = function(get, set, arg) {\n            return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n        };\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingMap = /* @__PURE__ */ new Map();\n    let storeListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        storeListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const setAtomState = (atom, atomState)=>{\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = atomStateMap.get(atom);\n        atomStateMap.set(atom, atomState);\n        if (!pendingMap.has(atom)) {\n            pendingMap.set(atom, prevAtomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies)=>{\n        const dependencies = /* @__PURE__ */ new Map();\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && a === atom) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!force && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (a === atom) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const addAtom = (atom)=>{\n        let mounted = mountedMap.get(atom);\n        if (!mounted) {\n            mounted = mountAtom(atom);\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const delAtom = (atom)=>{\n        const mounted = mountedMap.get(atom);\n        if (mounted && canUnmountAtom(atom, mounted)) {\n            unmountAtom(atom);\n        }\n    };\n    const recomputeDependents = (atom)=>{\n        const dependencyMap = /* @__PURE__ */ new Map();\n        const dirtyMap = /* @__PURE__ */ new WeakMap();\n        const getDependents = (a)=>{\n            var _a;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            pendingMap.forEach((_, pendingAtom)=>{\n                var _a2;\n                if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n                    dependents.add(pendingAtom);\n                }\n            });\n            return dependents;\n        };\n        const loop1 = (a)=>{\n            getDependents(a).forEach((dependent)=>{\n                if (dependent !== a) {\n                    dependencyMap.set(dependent, (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a));\n                    dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n                    loop1(dependent);\n                }\n            });\n        };\n        loop1(atom);\n        const loop2 = (a)=>{\n            getDependents(a).forEach((dependent)=>{\n                var _a;\n                if (dependent !== a) {\n                    let dirtyCount = dirtyMap.get(dependent);\n                    if (dirtyCount) {\n                        dirtyMap.set(dependent, --dirtyCount);\n                    }\n                    if (!dirtyCount) {\n                        let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n                        if (isChanged) {\n                            const prevAtomState = getAtomState(dependent);\n                            const nextAtomState = readAtomState(dependent, true);\n                            isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n                        }\n                        if (!isChanged) {\n                            dependencyMap.forEach((s)=>s.delete(dependent));\n                        }\n                    }\n                    loop2(dependent);\n                }\n            });\n        };\n        loop2(atom);\n    };\n    const writeAtomState = (atom, ...args)=>{\n        let isSync = true;\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            let r;\n            if (a === atom) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending();\n                if (( false ? 0 : void 0) !== \"production\") {\n                    storeListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        isSync = false;\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending();\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            const aMounted = mountedMap.get(a);\n            if (aMounted) {\n                aMounted.t.add(atom);\n            } else {\n                if (a !== atom) {\n                    mountAtom(a, atom, queue);\n                }\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const unmountAtom = (atom)=>{\n        var _a;\n        const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mounted = mountedMap.get(a);\n                    if (mounted) {\n                        mounted.t.delete(atom);\n                        if (canUnmountAtom(a, mounted)) {\n                            unmountAtom(a);\n                        }\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            maybeUnmountAtomSet.add(a);\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n            }\n        });\n        depSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.add(atom);\n            } else if (mountedMap.has(atom)) {\n                mountAtom(a, atom);\n            }\n        });\n        maybeUnmountAtomSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted && canUnmountAtom(a, mounted)) {\n                unmountAtom(a);\n            }\n        });\n    };\n    const flushPending = ()=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        while(pendingMap.size){\n            const pending = Array.from(pendingMap);\n            pendingMap.clear();\n            pending.forEach(([atom, prevAtomState])=>{\n                const atomState = getAtomState(atom);\n                if (atomState) {\n                    const mounted = mountedMap.get(atom);\n                    if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                        mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                    }\n                    if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                    (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                        mounted.l.forEach((listener)=>listener());\n                        if (( false ? 0 : void 0) !== \"production\") {\n                            flushed.add(atom);\n                        }\n                    }\n                } else if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n            });\n        }\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = addAtom(atom);\n        const flushed = flushPending();\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            delAtom(atom);\n            if (( false ? 0 : void 0) !== \"production\") {\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l, rev)=>{\n                if (rev !== 2) {\n                    throw new Error(\"The current StoreListener revision is 2.\");\n                }\n                storeListenersRev2.add(l);\n                return ()=>{\n                    storeListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending();\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nif (( false ? 0 : void 0) !== \"production\") {\n    if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n        ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n    } else {\n        globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n    }\n}\nconst getDefaultStore = ()=>{\n    if (!defaultStore) {\n        if (( false ? 0 : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n            console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n        }\n        defaultStore = createStore();\n    }\n    return defaultStore;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQyxVQUFVLElBQU1GO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPRixTQUFTLFlBQVk7UUFDOUJHLE9BQU9ILElBQUksR0FBR0E7SUFDaEIsT0FBTztRQUNMRyxPQUFPRSxJQUFJLEdBQUdMO1FBQ2RHLE9BQU9ILElBQUksR0FBRyxTQUFTTSxHQUFHO1lBQ3hCLE9BQU9BLElBQUksSUFBSTtRQUNqQjtRQUNBSCxPQUFPRixLQUFLLEdBQUcsU0FBU0ssR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7WUFDbkMsT0FBT0QsSUFDTCxJQUFJLEVBQ0osT0FBT0MsUUFBUSxhQUFhQSxJQUFJRixJQUFJLElBQUksS0FBS0U7UUFFakQ7SUFDRjtJQUNBLElBQUlQLE9BQU87UUFDVEUsT0FBT0YsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9FO0FBQ1Q7QUFFQSxNQUFNTSxrQkFBa0IsQ0FBQ1YsT0FBUyxVQUFVQTtBQUM1QyxNQUFNVyx5QkFBeUIsQ0FBQ1gsT0FBUyxDQUFDLENBQUNBLEtBQUtFLEtBQUs7QUFDckQsTUFBTVUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJQztBQUM3QyxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDdENKLGlCQUFpQkosR0FBRyxDQUFDTyxTQUFTQztJQUM5QkQsUUFBUUUsS0FBSyxDQUFDLEtBQ2QsR0FBR0MsT0FBTyxDQUFDLElBQU1OLGlCQUFpQk8sTUFBTSxDQUFDSjtBQUMzQztBQUNBLE1BQU1LLGdCQUFnQixDQUFDTCxTQUFTTTtJQUM5QixNQUFNTCxTQUFTSixpQkFBaUJMLEdBQUcsQ0FBQ1E7SUFDcEMsSUFBSUMsUUFB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Z0JBQ0Y7Z0JBQ0EsTUFBTWdJLFVBQVVDO2dCQUNoQmhGLG1CQUFtQmlCLE9BQU8sQ0FDeEIsQ0FBQ3VDLElBQU1BLEVBQUU7d0JBQUV5QixNQUFNO3dCQUFXRjtvQkFBUTtZQUV4QztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x6SCxLQUFLNkY7UUFDTDVGLEtBQUswRjtRQUNMb0QsS0FBS0Y7SUFDUDtBQUNGO0FBQ0EsSUFBSVU7QUFDSixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7SUFDdEUsSUFBSSxPQUFPQyxXQUFXQyw2QkFBNkIsS0FBSyxVQUFVO1FBQ2hFLEVBQUVELFdBQVdDLDZCQUE2QjtJQUM1QyxPQUFPO1FBQ0xELFdBQVdDLDZCQUE2QixHQUFHO0lBQzdDO0FBQ0Y7QUFDQSxNQUFNQyxrQkFBa0I7SUFDdEIsSUFBSSxDQUFDSCxjQUFjO1FBQ2pCLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCQyxXQUFXQyw2QkFBNkIsS0FBSyxHQUFHO1lBQ3hIM0YsUUFBUUMsSUFBSSxDQUNWO1FBRUo7UUFDQXdGLGVBQWVsSDtJQUNqQjtJQUNBLE9BQU9rSDtBQUNUO0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ29nZ2lucy1haS1jb2FjaC8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vdmFuaWxsYS5tanM/OWI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQga2V5Q291bnQgPSAwO1xuZnVuY3Rpb24gYXRvbShyZWFkLCB3cml0ZSkge1xuICBjb25zdCBrZXkgPSBgYXRvbSR7KytrZXlDb3VudH1gO1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdG9TdHJpbmc6ICgpID0+IGtleVxuICB9O1xuICBpZiAodHlwZW9mIHJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbmZpZy5yZWFkID0gcmVhZDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuaW5pdCA9IHJlYWQ7XG4gICAgY29uZmlnLnJlYWQgPSBmdW5jdGlvbihnZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcyk7XG4gICAgfTtcbiAgICBjb25maWcud3JpdGUgPSBmdW5jdGlvbihnZXQsIHNldCwgYXJnKSB7XG4gICAgICByZXR1cm4gc2V0KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoZ2V0KHRoaXMpKSA6IGFyZ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGhhc0luaXRpYWxWYWx1ZSA9IChhdG9tKSA9PiBcImluaXRcIiBpbiBhdG9tO1xuY29uc3QgaXNBY3R1YWxseVdyaXRhYmxlQXRvbSA9IChhdG9tKSA9PiAhIWF0b20ud3JpdGU7XG5jb25zdCBjYW5jZWxQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWdpc3RlckNhbmNlbFByb21pc2UgPSAocHJvbWlzZSwgY2FuY2VsKSA9PiB7XG4gIGNhbmNlbFByb21pc2VNYXAuc2V0KHByb21pc2UsIGNhbmNlbCk7XG4gIHByb21pc2UuY2F0Y2goKCkgPT4ge1xuICB9KS5maW5hbGx5KCgpID0+IGNhbmNlbFByb21pc2VNYXAuZGVsZXRlKHByb21pc2UpKTtcbn07XG5jb25zdCBjYW5jZWxQcm9taXNlID0gKHByb21pc2UsIG5leHQpID0+IHtcbiAgY29uc3QgY2FuY2VsID0gY2FuY2VsUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG4gIGlmIChjYW5jZWwpIHtcbiAgICBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKTtcbiAgICBjYW5jZWwobmV4dCk7XG4gIH1cbn07XG5jb25zdCByZXNvbHZlUHJvbWlzZSA9IChwcm9taXNlLCB2YWx1ZSkgPT4ge1xuICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gIHByb21pc2UudmFsdWUgPSB2YWx1ZTtcbn07XG5jb25zdCByZWplY3RQcm9taXNlID0gKHByb21pc2UsIGUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gIHByb21pc2UucmVhc29uID0gZTtcbn07XG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNFcXVhbEF0b21WYWx1ZSA9IChhLCBiKSA9PiAhIWEgJiYgXCJ2XCIgaW4gYSAmJiBcInZcIiBpbiBiICYmIE9iamVjdC5pcyhhLnYsIGIudik7XG5jb25zdCBpc0VxdWFsQXRvbUVycm9yID0gKGEsIGIpID0+ICEhYSAmJiBcImVcIiBpbiBhICYmIFwiZVwiIGluIGIgJiYgT2JqZWN0LmlzKGEuZSwgYi5lKTtcbmNvbnN0IGhhc1Byb21pc2VBdG9tVmFsdWUgPSAoYSkgPT4gISFhICYmIFwidlwiIGluIGEgJiYgYS52IGluc3RhbmNlb2YgUHJvbWlzZTtcbmNvbnN0IGlzRXF1YWxQcm9taXNlQXRvbVZhbHVlID0gKGEsIGIpID0+IFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBhLnYub3JpZyAmJiBhLnYub3JpZyA9PT0gYi52Lm9yaWc7XG5jb25zdCByZXR1cm5BdG9tVmFsdWUgPSAoYXRvbVN0YXRlKSA9PiB7XG4gIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICB0aHJvdyBhdG9tU3RhdGUuZTtcbiAgfVxuICByZXR1cm4gYXRvbVN0YXRlLnY7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBtb3VudGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHBlbmRpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgc3RvcmVMaXN0ZW5lcnNSZXYyO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBzdG9yZUxpc3RlbmVyc1JldjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgY29uc3QgZ2V0QXRvbVN0YXRlID0gKGF0b20pID0+IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gIGNvbnN0IHNldEF0b21TdGF0ZSA9IChhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIGlmICghcGVuZGluZ01hcC5oYXMoYXRvbSkpIHtcbiAgICAgIHBlbmRpbmdNYXAuc2V0KGF0b20sIHByZXZBdG9tU3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSkge1xuICAgICAgY29uc3QgbmV4dCA9IFwidlwiIGluIGF0b21TdGF0ZSA/IGF0b21TdGF0ZS52IGluc3RhbmNlb2YgUHJvbWlzZSA/IGF0b21TdGF0ZS52IDogUHJvbWlzZS5yZXNvbHZlKGF0b21TdGF0ZS52KSA6IFByb21pc2UucmVqZWN0KGF0b21TdGF0ZS5lKTtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLnYgIT09IG5leHQpIHtcbiAgICAgICAgY2FuY2VsUHJvbWlzZShwcmV2QXRvbVN0YXRlLnYsIG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlRGVwZW5kZW5jaWVzID0gKGF0b20sIG5leHRBdG9tU3RhdGUsIG5leHREZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgbmV4dERlcGVuZGVuY2llcy5mb3JFYWNoKChhU3RhdGUsIGEpID0+IHtcbiAgICAgIGlmICghYVN0YXRlICYmIGEgPT09IGF0b20pIHtcbiAgICAgICAgYVN0YXRlID0gbmV4dEF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUpO1xuICAgICAgICBpZiAobmV4dEF0b21TdGF0ZS5kLmdldChhKSAhPT0gYVN0YXRlKSB7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gYXRvbSBzdGF0ZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgbmV4dEF0b21TdGF0ZS5kLnNpemUgIT09IGRlcGVuZGVuY2llcy5zaXplKSB7XG4gICAgICBuZXh0QXRvbVN0YXRlLmQgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWUgPSAoYXRvbSwgdmFsdWUsIG5leHREZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgdjogdmFsdWVcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgaGFzUHJvbWlzZUF0b21WYWx1ZShuZXh0QXRvbVN0YXRlKSAmJiBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgaWYgKHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEF0b21TdGF0ZS52ID0gcHJldkF0b21TdGF0ZS52O1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcywgYWJvcnRQcm9taXNlKSA9PiB7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICBsZXQgY29udGludWVQcm9taXNlO1xuICAgICAgY29uc3QgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgaWYgKCFoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpIHx8IHByZXZBdG9tU3RhdGUudiAhPT0gcHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlKFxuICAgICAgICAgIGF0b20sXG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSAmJiBwcmV2QXRvbVN0YXRlLmQgIT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgc2V0dGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKFxuICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpO1xuICAgICAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHByb21pc2UsIGUpO1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlUHJvbWlzZSA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQudGhlbihcbiAgICAgICAgICAgICAgKHYpID0+IHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpLFxuICAgICAgICAgICAgICAoZSkgPT4gcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc29sdmUobmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlLm9yaWcgPSB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICByZWdpc3RlckNhbmNlbFByb21pc2UocHJvbWlzZSwgKG5leHQpID0+IHtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBjb250aW51ZVByb21pc2UobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRQcm9taXNlID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFByb21pc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCBwcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21FcnJvciA9IChhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGQ6IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBlOiBlcnJvclxuICAgIH07XG4gICAgaWYgKG5leHREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaWYgKGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkgJiYgcHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAoYXRvbSwgZm9yY2UpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCFmb3JjZSAmJiBhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KChbYSwgc10pID0+IHtcbiAgICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgICByZXR1cm4gYVN0YXRlID09PSBzIHx8IGlzRXF1YWxBdG9tVmFsdWUoYVN0YXRlLCBzKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHREZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiB7XG4gICAgICBpZiAoYSA9PT0gYXRvbSkge1xuICAgICAgICBjb25zdCBhU3RhdGUyID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBpZiAoYVN0YXRlMikge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZTIpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIHZvaWQgMCk7XG4gICAgICAgICAgcmV0dXJuIGEuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhdG9tIGluaXRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgbmV4dERlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlKTtcbiAgICB9O1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzZXRTZWxmO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2V0U2VsZigpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTZWxmO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlT3JQcm9taXNlID0gYXRvbS5yZWFkKGdldHRlciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2V0QXRvbVZhbHVlT3JQcm9taXNlKFxuICAgICAgICBhdG9tLFxuICAgICAgICB2YWx1ZU9yUHJvbWlzZSxcbiAgICAgICAgbmV4dERlcGVuZGVuY2llcyxcbiAgICAgICAgKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gc2V0QXRvbUVycm9yKGF0b20sIGVycm9yLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbSA9IChhdG9tKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhdG9tKSk7XG4gIGNvbnN0IGFkZEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGxldCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICBtb3VudGVkID0gbW91bnRBdG9tKGF0b20pO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgY2FuVW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4gIW1vdW50ZWQubC5zaXplICYmICghbW91bnRlZC50LnNpemUgfHwgbW91bnRlZC50LnNpemUgPT09IDEgJiYgbW91bnRlZC50LmhhcyhhdG9tKSk7XG4gIGNvbnN0IGRlbEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBpZiAobW91bnRlZCAmJiBjYW5Vbm1vdW50QXRvbShhdG9tLCBtb3VudGVkKSkge1xuICAgICAgdW5tb3VudEF0b20oYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWNvbXB1dGVEZXBlbmRlbnRzID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmN5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBkaXJ0eU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGdldERlcGVuZGVudHMgPSAoYSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IG5ldyBTZXQoKF9hID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50KTtcbiAgICAgIHBlbmRpbmdNYXAuZm9yRWFjaCgoXywgcGVuZGluZ0F0b20pID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKChfYTIgPSBnZXRBdG9tU3RhdGUocGVuZGluZ0F0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmQuaGFzKGEpKSB7XG4gICAgICAgICAgZGVwZW5kZW50cy5hZGQocGVuZGluZ0F0b20pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXBlbmRlbnRzO1xuICAgIH07XG4gICAgY29uc3QgbG9vcDEgPSAoYSkgPT4ge1xuICAgICAgZ2V0RGVwZW5kZW50cyhhKS5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgaWYgKGRlcGVuZGVudCAhPT0gYSkge1xuICAgICAgICAgIGRlcGVuZGVuY3lNYXAuc2V0KFxuICAgICAgICAgICAgZGVwZW5kZW50LFxuICAgICAgICAgICAgKGRlcGVuZGVuY3lNYXAuZ2V0KGRlcGVuZGVudCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkuYWRkKGEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXJ0eU1hcC5zZXQoZGVwZW5kZW50LCAoZGlydHlNYXAuZ2V0KGRlcGVuZGVudCkgfHwgMCkgKyAxKTtcbiAgICAgICAgICBsb29wMShkZXBlbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGxvb3AxKGF0b20pO1xuICAgIGNvbnN0IGxvb3AyID0gKGEpID0+IHtcbiAgICAgIGdldERlcGVuZGVudHMoYSkuZm9yRWFjaCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRlcGVuZGVudCAhPT0gYSkge1xuICAgICAgICAgIGxldCBkaXJ0eUNvdW50ID0gZGlydHlNYXAuZ2V0KGRlcGVuZGVudCk7XG4gICAgICAgICAgaWYgKGRpcnR5Q291bnQpIHtcbiAgICAgICAgICAgIGRpcnR5TWFwLnNldChkZXBlbmRlbnQsIC0tZGlydHlDb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlydHlDb3VudCkge1xuICAgICAgICAgICAgbGV0IGlzQ2hhbmdlZCA9ICEhKChfYSA9IGRlcGVuZGVuY3lNYXAuZ2V0KGRlcGVuZGVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaXplKTtcbiAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShkZXBlbmRlbnQpO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gcmVhZEF0b21TdGF0ZShkZXBlbmRlbnQsIHRydWUpO1xuICAgICAgICAgICAgICBpc0NoYW5nZWQgPSAhaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY3lNYXAuZm9yRWFjaCgocykgPT4gcy5kZWxldGUoZGVwZW5kZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvb3AyKGRlcGVuZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgbG9vcDIoYXRvbSk7XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gKGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYSkpO1xuICAgIGNvbnN0IHNldHRlciA9IChhLCAuLi5hcmdzMikgPT4ge1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoYSA9PT0gYXRvbSkge1xuICAgICAgICBpZiAoIWhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0b20gbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSBzZXRBdG9tVmFsdWVPclByb21pc2UoYSwgYXJnczJbMF0pO1xuICAgICAgICBpZiAoIWlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gd3JpdGVBdG9tU3RhdGUoYSwgLi4uYXJnczIpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZygpO1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJhc3luYy13cml0ZVwiLCBmbHVzaGVkIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHdyaXRlQXRvbVN0YXRlKGF0b20sIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwid3JpdGVcIiwgZmx1c2hlZCB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29uc3QgbW91bnRBdG9tID0gKGF0b20sIGluaXRpYWxEZXBlbmRlbnQsIG9uTW91bnRRdWV1ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBxdWV1ZSA9IG9uTW91bnRRdWV1ZSB8fCBbXTtcbiAgICAoX2EgPSBnZXRBdG9tU3RhdGUoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGNvbnN0IGFNb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAoYU1vdW50ZWQpIHtcbiAgICAgICAgYU1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIG1vdW50QXRvbShhLCBhdG9tLCBxdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWFkQXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG1vdW50ZWQgPSB7XG4gICAgICB0OiBuZXcgU2V0KGluaXRpYWxEZXBlbmRlbnQgJiYgW2luaXRpYWxEZXBlbmRlbnRdKSxcbiAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIG1vdW50ZWRNYXAuc2V0KGF0b20sIG1vdW50ZWQpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmFkZChhdG9tKTtcbiAgICB9XG4gICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkgJiYgYXRvbS5vbk1vdW50KSB7XG4gICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudCgoLi4uYXJncykgPT4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG1vdW50ZWQudSA9IG9uVW5tb3VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb25Nb3VudFF1ZXVlKSB7XG4gICAgICBxdWV1ZS5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgdW5tb3VudEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvblVubW91bnQgPSAoX2EgPSBtb3VudGVkTWFwLmdldChhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnU7XG4gICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgb25Vbm1vdW50KCk7XG4gICAgfVxuICAgIG1vdW50ZWRNYXAuZGVsZXRlKGF0b20pO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmRlbGV0ZShhdG9tKTtcbiAgICB9XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKGF0b21TdGF0ZSkpIHtcbiAgICAgICAgY2FuY2VsUHJvbWlzZShhdG9tU3RhdGUudik7XG4gICAgICB9XG4gICAgICBhdG9tU3RhdGUuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICAgIGlmIChhICE9PSBhdG9tKSB7XG4gICAgICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBtb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgICAgICAgaWYgKGNhblVubW91bnRBdG9tKGEsIG1vdW50ZWQpKSB7XG4gICAgICAgICAgICAgIHVubW91bnRBdG9tKGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gY291bGQgbm90IGZpbmQgYXRvbSBzdGF0ZSB0byB1bm1vdW50XCIsIGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnREZXBlbmRlbmNpZXMgPSAoYXRvbSwgYXRvbVN0YXRlLCBwcmV2RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwU2V0ID0gbmV3IFNldChhdG9tU3RhdGUuZC5rZXlzKCkpO1xuICAgIGNvbnN0IG1heWJlVW5tb3VudEF0b21TZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHByZXZEZXBlbmRlbmNpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZEZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGRlcFNldC5oYXMoYSkpIHtcbiAgICAgICAgZGVwU2V0LmRlbGV0ZShhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF5YmVVbm1vdW50QXRvbVNldC5hZGQoYSk7XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICBtb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlcFNldC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICBtb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfSBlbHNlIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICBtb3VudEF0b20oYSwgYXRvbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWF5YmVVbm1vdW50QXRvbVNldC5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAobW91bnRlZCAmJiBjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICB1bm1vdW50QXRvbShhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2hQZW5kaW5nID0gKCkgPT4ge1xuICAgIGxldCBmbHVzaGVkO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZmx1c2hlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHdoaWxlIChwZW5kaW5nTWFwLnNpemUpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmcgPSBBcnJheS5mcm9tKHBlbmRpbmdNYXApO1xuICAgICAgcGVuZGluZ01hcC5jbGVhcigpO1xuICAgICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgICAgICAgIGlmIChtb3VudGVkICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgYXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgICAgLy8gTWF5YmUgd2UgY291bGQgYG1vdW50RGVwZW5kZW5jaWVzYCBpbiBgc2V0QXRvbVN0YXRlYD9cbiAgICAgICAgICAoIWhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgKGlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSB8fCBpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIGF0b21TdGF0ZSkpKSkge1xuICAgICAgICAgICAgbW91bnRlZC5sLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBmbHVzaGVkLmFkZChhdG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBubyBhdG9tIHN0YXRlIHRvIGZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmx1c2hlZDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gYWRkQXRvbShhdG9tKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJzdWJcIiwgZmx1c2hlZCB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgZGVsQXRvbShhdG9tKTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwidW5zdWJcIiB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogcmVhZEF0b20sXG4gICAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICAgIHN1Yjogc3Vic2NyaWJlQXRvbSxcbiAgICAgIC8vIHN0b3JlIGRldiBtZXRob2RzICh0aGVzZSBhcmUgdGVudGF0aXZlIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZSlcbiAgICAgIGRldl9zdWJzY3JpYmVfc3RvcmU6IChsLCByZXYpID0+IHtcbiAgICAgICAgaWYgKHJldiAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IFN0b3JlTGlzdGVuZXIgcmV2aXNpb24gaXMgMi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmFkZChsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZGVsZXRlKGwpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRldl9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gbW91bnRlZEF0b21zLnZhbHVlcygpLFxuICAgICAgZGV2X2dldF9hdG9tX3N0YXRlOiAoYSkgPT4gYXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIGRldl9nZXRfbW91bnRlZDogKGEpID0+IG1vdW50ZWRNYXAuZ2V0KGEpLFxuICAgICAgZGV2X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVPclByb21pc2VdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIHNldEF0b21WYWx1ZU9yUHJvbWlzZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJyZXN0b3JlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b21cbiAgfTtcbn07XG5sZXQgZGVmYXVsdFN0b3JlO1xuaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXyA9PT0gXCJudW1iZXJcIikge1xuICAgICsrZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fID0gMTtcbiAgfVxufVxuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fICE9PSAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIl0sIm5hbWVzIjpbImtleUNvdW50IiwiYXRvbSIsInJlYWQiLCJ3cml0ZSIsImtleSIsImNvbmZpZyIsInRvU3RyaW5nIiwiaW5pdCIsImdldCIsInNldCIsImFyZyIsImhhc0luaXRpYWxWYWx1ZSIsImlzQWN0dWFsbHlXcml0YWJsZUF0b20iLCJjYW5jZWxQcm9taXNlTWFwIiwiV2Vha01hcCIsInJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSIsInByb21pc2UiLCJjYW5jZWwiLCJjYXRjaCIsImZpbmFsbHkiLCJkZWxldGUiLCJjYW5jZWxQcm9taXNlIiwibmV4dCIsInJlc29sdmVQcm9taXNlIiwidmFsdWUiLCJzdGF0dXMiLCJyZWplY3RQcm9taXNlIiwiZSIsInJlYXNvbiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImlzRXF1YWxBdG9tVmFsdWUiLCJhIiwiYiIsIk9iamVjdCIsImlzIiwidiIsImlzRXF1YWxBdG9tRXJyb3IiLCJoYXNQcm9taXNlQXRvbVZhbHVlIiwiUHJvbWlzZSIsImlzRXF1YWxQcm9taXNlQXRvbVZhbHVlIiwib3JpZyIsInJldHVybkF0b21WYWx1ZSIsImF0b21TdGF0ZSIsImNyZWF0ZVN0b3JlIiwiYXRvbVN0YXRlTWFwIiwibW91bnRlZE1hcCIsInBlbmRpbmdNYXAiLCJNYXAiLCJzdG9yZUxpc3RlbmVyc1JldjIiLCJtb3VudGVkQXRvbXMiLCJlbnYiLCJNT0RFIiwiU2V0IiwiZ2V0QXRvbVN0YXRlIiwic2V0QXRvbVN0YXRlIiwiZnJlZXplIiwicHJldkF0b21TdGF0ZSIsImhhcyIsInJlc29sdmUiLCJyZWplY3QiLCJ1cGRhdGVEZXBlbmRlbmNpZXMiLCJuZXh0QXRvbVN0YXRlIiwibmV4dERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImNoYW5nZWQiLCJmb3JFYWNoIiwiYVN0YXRlIiwiZCIsImNvbnNvbGUiLCJ3YXJuIiwic2l6ZSIsInNldEF0b21WYWx1ZSIsInNldEF0b21WYWx1ZU9yUHJvbWlzZSIsInZhbHVlT3JQcm9taXNlIiwiYWJvcnRQcm9taXNlIiwiY29udGludWVQcm9taXNlIiwidXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyIsIm1vdW50RGVwZW5kZW5jaWVzIiwic2V0dGxlZCIsInNldEF0b21FcnJvciIsImVycm9yIiwicmVhZEF0b21TdGF0ZSIsImZvcmNlIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJzIiwiaXNTeW5jIiwiZ2V0dGVyIiwiYVN0YXRlMiIsIkVycm9yIiwiY29udHJvbGxlciIsInNldFNlbGYiLCJvcHRpb25zIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiYXJncyIsIndyaXRlQXRvbSIsImFib3J0IiwicmVhZEF0b20iLCJhZGRBdG9tIiwibW91bnRlZCIsIm1vdW50QXRvbSIsImNhblVubW91bnRBdG9tIiwibCIsInQiLCJkZWxBdG9tIiwidW5tb3VudEF0b20iLCJyZWNvbXB1dGVEZXBlbmRlbnRzIiwiZGVwZW5kZW5jeU1hcCIsImRpcnR5TWFwIiwiZ2V0RGVwZW5kZW50cyIsIl9hIiwiZGVwZW5kZW50cyIsIl8iLCJwZW5kaW5nQXRvbSIsIl9hMiIsImFkZCIsImxvb3AxIiwiZGVwZW5kZW50IiwibG9vcDIiLCJkaXJ0eUNvdW50IiwiaXNDaGFuZ2VkIiwid3JpdGVBdG9tU3RhdGUiLCJzZXR0ZXIiLCJhcmdzMiIsInIiLCJmbHVzaGVkIiwiZmx1c2hQZW5kaW5nIiwidHlwZSIsInJlc3VsdCIsImluaXRpYWxEZXBlbmRlbnQiLCJvbk1vdW50UXVldWUiLCJxdWV1ZSIsImFNb3VudGVkIiwib25Nb3VudCIsInB1c2giLCJvblVubW91bnQiLCJ1IiwiZiIsInByZXZEZXBlbmRlbmNpZXMiLCJkZXBTZXQiLCJrZXlzIiwibWF5YmVVbm1vdW50QXRvbVNldCIsInBlbmRpbmciLCJjbGVhciIsImxpc3RlbmVyIiwic3Vic2NyaWJlQXRvbSIsImxpc3RlbmVycyIsInN1YiIsImRldl9zdWJzY3JpYmVfc3RvcmUiLCJyZXYiLCJkZXZfZ2V0X21vdW50ZWRfYXRvbXMiLCJ2YWx1ZXMiLCJkZXZfZ2V0X2F0b21fc3RhdGUiLCJkZXZfZ2V0X21vdW50ZWQiLCJkZXZfcmVzdG9yZV9hdG9tcyIsImRlZmF1bHRTdG9yZSIsImdsb2JhbFRoaXMiLCJfX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXyIsImdldERlZmF1bHRTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;